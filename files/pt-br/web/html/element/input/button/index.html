---
title: <input type="button">
slug: Web/HTML/Element/Input/button
tags:
  - Documentação
  - Element
  - Elementos Input
  - Formulários HTML
  - HTML
  - Input
  - Referencia
  - Tipos de Input
  - botões
  - button
  - formulários
translation_of: Web/HTML/Element/input/button
---
<div>{{HTMLRef}}</div>

<p><span class="seoSummary">Elementos {{HTMLElement("input")}} do tipo <strong><code>button</code> </strong>são renderizados como um simples botão, que podem ser programados para controlar funcionalidades customizadas em qualquer lugar de uma página web quando for atribuído um evento (tipicamente para um evento {{event("click")}}).</span></p>

<div>{{EmbedInteractiveExample("pages/tabbed/input-button.html", "tabbed-shorter")}}</div>

<p class="hidden">A fonte para estes exemplos interativos é armazenado em um repositório GitHub. Se você gostaria de contribuir com projetos de exemplos interativos, por favor clone <a href="https://github.com/mdn/interactive-examples">https://github.com/mdn/interactive-examples</a> e envie-nos uma requisição pull.</p>

<div class="note">
<p><strong>Nota</strong>: Enquanto elementos <code>&lt;input&gt;</code> do tipo <code>button</code> ainda são perfeitamente válidos, os novos elementos {{HTMLElement("button")}} são agora os favoráveis meios para criar botões. Uma etiqueta de texto (label) para um {{HTMLElement("button")}} pode ser inserida entre uma tag de abertura e outra de fechamento, podendo ser incluídas até imagens.</p>
</div>

<table class="properties">
 <tbody>
  <tr>
   <td><strong>{{anch("Value")}}</strong></td>
   <td>Um {{domxref("DOMString")}} usado como uma etiqueta de botão.</td>
  </tr>
  <tr>
   <td><strong>Eventos</strong></td>
   <td>{{event("click")}}</td>
  </tr>
  <tr>
   <td><strong>Atributos comuns suportados</strong></td>
   <td>{{htmlattrxref("type", "input")}}, e {{htmlattrxref("value", "input")}}</td>
  </tr>
  <tr>
   <td><strong>atributos IDL</strong></td>
   <td><code>value</code></td>
  </tr>
  <tr>
   <td><strong>Métodos</strong></td>
   <td>Nenhum</td>
  </tr>
 </tbody>
</table>

<h2 id="Value">Value</h2>

<p>Seu atributo {{htmlattrxref("value", "input")}} de um elemento <code>&lt;input type="button"&gt;</code>  contém uma {{domxref("DOMString")}} que é usado como uma etiqueta (label) de um botão</p>

<div id="summary-example3">
<pre class="brush: html">&lt;input type="button" value="Click Me"&gt;</pre>
</div>

<p>{{EmbedLiveSample("summary-example3", 650, 30)}}</p>

<p>Se você não especificar um <code>value</code>, você obtém um botão vazio:</p>

<div id="summary-example1">
<pre class="brush: html">&lt;input type="button"&gt;</pre>
</div>

<p>{{EmbedLiveSample("summary-example1", 650, 30)}}</p>

<h2 id="Usando_buttons">Usando buttons</h2>

<p>Elementos <code>&lt;input type="button"&gt;</code> não possuem comportamento padrão (seu primos,<code> <a href="/en-US/docs/Web/HTML/Element/input/submit">&lt;input type="submit"&gt;</a></code> e <code><a href="/en-US/docs/Web/HTML/Element/input/reset">&lt;input type="reset"&gt;</a></code> são usados para submeter e resetar formulários). Para que botões possam fazer algo, você tem de escrever um código em JavaScript para fazê-lo trabalhar.</p>

<h3 id="Um_simples_botão">Um simples botão</h3>

<p>Nós iremos começar criando um simples botão com um evento {{event("click")}} que inicia nossa máquina (bem, ele altera o <code>value</code> do botão e o contéudo texto do seguinte parágrafo):</p>

<pre class="brush: html">&lt;form&gt;
  &lt;input type="button" value="Start machine"&gt;
&lt;/form&gt;
&lt;p&gt;The machine is stopped.&lt;/p&gt;</pre>

<pre class="brush: js">const button = document.querySelector('input');
const paragraph = document.querySelector('p');

button.addEventListener('click', updateButton);

function updateButton() {
  if (button.value === 'Start machine') {
    button.value = 'Stop machine';
    paragraph.textContent = 'The machine has started!';
  } else {
    button.value = 'Start machine';
    paragraph.textContent = 'The machine is stopped.';
  }
}</pre>

<p>O script recebe uma referência para o objeto {{domxref("HTMLInputElement")}} representando o <code>&lt;input&gt;</code> no DOM, salvando esta referência na variável <code>button</code>. {{domxref("EventTarget.addEventListener", "addEventListener()")}} é então usado para criar uma função que será chamada quando o evento {{event("click")}} for executado no botão.</p>

<p>{{EmbedLiveSample("A_simple_button", 650, 100)}}</p>

<h3 id="Adicionando_atalhos_de_teclados_aos_botões">Adicionando atalhos de teclados aos botões</h3>

<p>Keyboard shortcuts, also known as access keys and keyboard equivalents, let the user trigger a button using a key or combination of keys on the keyboard. To add a keyboard shortcut to a button — just as you would with any {{HTMLElement("input")}} for which it makes sense — you use the {{htmlattrxref("accesskey")}} global attribute.</p>

<p>In this example, <kbd>s</kbd> is specified as the access key (you'll need to press <kbd>s</kbd> plus the particular modifier keys for your browser/OS combination; see <a href="/en-US/docs/Web/HTML/Global_attributes/accesskey">accesskey</a> for a useful list of those).</p>

<div id="accesskey-example1">
<pre class="brush: html">&lt;form&gt;
  &lt;input type="button" value="Start machine" accesskey="s"&gt;
&lt;/form&gt;
&lt;p&gt;The machine is stopped.&lt;/p&gt;
</pre>
</div>

<div class="hidden">
<pre class="brush: js">const button = document.querySelector('input');
const paragraph = document.querySelector('p');

button.addEventListener('click', updateButton);

function updateButton() {
  if (button.value === 'Start machine') {
    button.value = 'Stop machine';
    paragraph.textContent = 'The machine has started!';
  } else {
    button.value = 'Start machine';
    paragraph.textContent = 'The machine is stopped.';
  }
}</pre>
</div>

<p>{{EmbedLiveSample("Adding_keyboard_shortcuts_to_buttons", 650, 100)}}</p>

<div class="note">
<p><strong>Note</strong>: The problem with the above example of course is that the user will not know what the access key is! In a real site, you'd have to provide this information in a way that doesn't intefere with the site design (for example by providing an easily accessible link that points to information on what the site accesskeys are).</p>
</div>

<h3 id="Desativando_e_ativando_um_botão">Desativando e ativando um botão</h3>

<p>To disable a button, simply specify the {{htmlattrxref("disabled")}} global attribute on it, like so:</p>

<div id="disable-example1">
<pre class="brush: html">&lt;input type="button" value="Disable me" disabled&gt;</pre>
</div>

<p>You can enable and disable buttons at run time by simply setting <code>disabled</code> to <code>true</code> or <code>false</code>. In this example our button starts off enabled, but if you press it, it is disabled using <code>button.disabled = true</code>. A {{domxref("WindowTimers.setTimeout","setTimeout()")}} function is then used to reset the button back to its enabled state after two seconds.</p>

<div class="hidden">
<h6 id="Hidden_code_1">Hidden code 1</h6>

<pre class="brush: html">&lt;input type="button" value="Enabled"&gt;</pre>

<pre class="brush: js">const button = document.querySelector('input');

button.addEventListener('click', disableButton);

function disableButton() {
  button.disabled = true;
  button.value = 'Disabled';
  window.setTimeout(function() {
    button.disabled = false;
    button.value = 'Enabled';
  }, 2000);
}</pre>
</div>

<p>{{EmbedLiveSample("Hidden_code_1", 650, 60)}}</p>

<p>If the <code>disabled</code> attribute isn't specified, the button inherits its <code>disabled</code> state from its parent element. This makes it possible to enable and disable groups of elements all at once by enclosing them in a container such as a {{HTMLElement("fieldset")}} element, and then setting <code>disabled</code> on the container.</p>

<p>The example below shows this in action. This is very similar to the previous example, except that the <code>disabled</code> attribute is set on the <code>&lt;fieldset&gt;</code> when the first button is pressed — this causes all three buttons to be disabled until the two second timeout has passed.</p>

<div class="hidden">
<h6 id="Hidden_code_2">Hidden code 2</h6>

<pre class="brush: html">&lt;fieldset&gt;
  &lt;legend&gt;Button group&lt;/legend&gt;
  &lt;input type="button" value="Button 1"&gt;
  &lt;input type="button" value="Button 2"&gt;
  &lt;input type="button" value="Button 3"&gt;
&lt;/fieldset&gt;</pre>

<pre class="brush: js">const button = document.querySelector('input');
const fieldset = document.querySelector('fieldset');

button.addEventListener('click', disableButton);

function disableButton() {
  fieldset.disabled = true;
  window.setTimeout(function() {
    fieldset.disabled = false;
  }, 2000);
}</pre>
</div>

<p>{{EmbedLiveSample("Hidden_code_2", 650, 60)}}</p>

<div class="note">
<p><strong>Note</strong>: Firefox will, unlike other browsers, by default, <a href="http://stackoverflow.com/questions/5985839/bug-with-firefox-disabled-attribute-of-input-not-resetting-when-refreshing">persist the dynamic disabled state</a> of a {{HTMLElement("button")}} across page loads. Use the {{htmlattrxref("autocomplete","button")}} attribute to control this feature.</p>
</div>

<h2 id="Validação">Validação</h2>

<p>Buttons não participam na validação; eles não tem um valor real para ser restringido.</p>

<h2 id="Exemplos">Exemplos</h2>

<p>The below example shows a very simple drawing app created using a {{htmlelement("canvas")}} element and some simple CSS and JavaScript (we'll hide the CSS for brevity). The top two controls allow you to choose the color and size of the drawing pen. The button, when clicked, invokes a function that clears the canvas.</p>

<pre class="brush: html">&lt;div class="toolbar"&gt;
  &lt;input type="color" aria-label="select pen color"&gt;
  &lt;input type="range" min="2" max="50" value="30" aria-label="select pen size"&gt;&lt;span class="output"&gt;30&lt;/span&gt;
  &lt;input type="button" value="Clear canvas"&gt;
&lt;/div&gt;

&lt;canvas class="myCanvas"&gt;
  &lt;p&gt;Add suitable fallback here.&lt;/p&gt;
&lt;/canvas&gt;</pre>

<div class="hidden">
<pre class="brush: css">body {
  background: #ccc;
  margin: 0;
  overflow: hidden;
}

.toolbar {
  background: #ccc;
  width: 150px;
  height: 75px;
  padding: 5px;
}

input[type="color"], input[type="button"] {
  width: 90%;
  margin: 0 auto;
  display: block;
}

input[type="range"] {
  width: 70%;
}

span {
  position: relative;
  bottom: 5px;
}</pre>
</div>

<pre class="brush: js">var canvas = document.querySelector('.myCanvas');
var width = canvas.width = window.innerWidth;
var height = canvas.height = window.innerHeight-85;
var ctx = canvas.getContext('2d');

ctx.fillStyle = 'rgb(0,0,0)';
ctx.fillRect(0,0,width,height);

var colorPicker = document.querySelector('input[type="color"]');
var sizePicker = document.querySelector('input[type="range"]');
var output = document.querySelector('.output');
var clearBtn = document.querySelector('input[type="button"]');

// covert degrees to radians
function degToRad(degrees) {
  return degrees * Math.PI / 180;
};

// update sizepicker output value

sizePicker.oninput = function() {
  output.textContent = sizePicker.value;
}

// store mouse pointer coordinates, and whether the button is pressed
var curX;
var curY;
var pressed = false;

// update mouse pointer coordinates
document.onmousemove = function(e) {
  curX = (window.Event) ? e.pageX : e.clientX + (document.documentElement.scrollLeft ? document.documentElement.scrollLeft : document.body.scrollLeft);
  curY = (window.Event) ? e.pageY : e.clientY + (document.documentElement.scrollTop ? document.documentElement.scrollTop : document.body.scrollTop);
}

canvas.onmousedown = function() {
  pressed = true;
};

canvas.onmouseup = function() {
  pressed = false;
}

clearBtn.onclick = function() {
  ctx.fillStyle = 'rgb(0,0,0)';
  ctx.fillRect(0,0,width,height);
}

function draw() {
  if(pressed) {
    ctx.fillStyle = colorPicker.value;
    ctx.beginPath();
    ctx.arc(curX, curY-85, sizePicker.value, degToRad(0), degToRad(360), false);
    ctx.fill();
  }

  requestAnimationFrame(draw);
}

draw();</pre>

<p>{{EmbedLiveSample("Examples", '100%', 600)}}</p>

<h2 id="Específicações">Específicações</h2>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Specification</th>
   <th scope="col">Status</th>
   <th scope="col">Comments</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>{{SpecName('HTML WHATWG', 'forms.html#button-state-(type=button)', '&lt;input type="button"&gt;')}}</td>
   <td>{{Spec2('HTML WHATWG')}}</td>
   <td></td>
  </tr>
  <tr>
   <td>{{SpecName('HTML5 W3C', 'forms.html#button-state-(type=button)', '&lt;input type="button"&gt;')}}</td>
   <td>{{Spec2('HTML5 W3C')}}</td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Browser_compatibility">Compatibilidade com navegadores</h2>

<p>{{Compat("html.elements.input.input-button")}}</p>

<h2 id="Veja_também">Veja também</h2>

<ul>
 <li>{{HTMLElement("input")}} and the {{domxref("HTMLInputElement")}} interface which implements it.</li>
 <li>The more modern {{HTMLElement("button")}} element.</li>
 <li><a href="/en-US/docs/Learn/HTML/Forms/Property_compatibility_table_for_form_widgets">Compatibility of CSS properties</a></li>
</ul>
