---
title: new.target
slug: Web/JavaScript/Reference/Operators/new.target
tags:
  - ECMAScript6
  - JavaScript
translation_of: Web/JavaScript/Reference/Operators/new.target
---
<div>{{JSSidebar("Operators")}}</div>

<div>Свойство <strong><code>new.target</code></strong> позволяет определить была ли функция или конструктор вызваны с помощью оператора <a href="/ru/docs/Web/JavaScript/Reference/Operators/new">new</a>. В конструкторах и функциях инстанциированных с помощью оператора <a href="/ru/docs/Web/JavaScript/Reference/Operators/new">new</a>,  <code>new.target</code> возвращает ссылку на конструктор или функцию. При обычном вызове функции <code>new.target</code> имеет значение {{jsxref("undefined")}}.</div>

<h2 id="Синтаксис">Синтаксис</h2>

<pre class="syntaxbox">new.target</pre>

<h2 id="Описание">Описание</h2>

<p>Синтаксис <code>new.target</code> состоит из ключевого слова<code>"new</code>", точки, и свойства<code> "target"</code>. Обычно "<code>new."</code> служит контекстом для доступа к свойству, но здесь <code>"new."</code> не совсем объект. Однако при вызове конструктора, <code>new.target</code> ссылается на конструктор вызванный с помощью <code>new</code> и таким образом "<code>new.</code>" становится виртуальным контекстом.</p>

<p>Свойство <code>new.target</code> это мета свойство которое доступно во всех функциях. В <a href="/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions">стрелочных функция</a>, <code>new.target</code> ссылается на <code>new.target</code> внешней функции.</p>

<h2 id="Примеры">Примеры</h2>

<h3 id="new.target_в_вызове_функции">new.target в вызове функции</h3>

<p>При обычном вызове функции (в противоположность вызову в качестве конструктора), <code>new.target</code> имеет значение {{jsxref("undefined")}}. Это позволяет определить была ли вызвана функция как конструктор через <a href="/en-US/docs/Web/JavaScript/Reference/Operators/new">new</a> или нет.</p>

<pre class="brush: js">function Foo() {
  if (!new.target) throw "Foo() must be called with new";
  console.log("Foo instantiated with new");
}

new Foo(); // выведет "Foo instantiated with new"
Foo(); // ошибка "Foo() must be called with new"
</pre>

<h3 id="new.target_в_конструкторе">new.target в конструкторе</h3>

<p>В конструкторе класса, <code>new.target</code> ссылается на конструктор, который был непосредственно вызван <code>new</code>. Это верно и для случая, когда <code>new.target</code> находится в конструкторе родительского класса, а тот в свою очередь вызывается из конструктора дочернего класса.</p>

<pre class="brush: js">class A {
  constructor() {
    console.log(new.target.name);
  }
}

class B extends A { constructor() { super(); } }

var a = new A(); // вернёт "A"
var b = new B(); // вернёт "B"
</pre>

<h2 id="Спецификации">Спецификации</h2>

{{Specifications}}

<h2 id="Совместимость_с_браузерами">Совместимость с браузерами</h2>

<p>{{Compat}}</p>

<h2 id="Смотрите_также">Смотрите также</h2>

<ul>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Functions">Functions</a></li>
 <li><a href="/en-US/docs/Web/JavaScript/Reference/Classes">Classes</a></li>
 <li><code><a href="/en-US/docs/Web/JavaScript/Reference/Operators/new">new</a></code></li>
 <li><code><a href="/en-US/docs/Web/JavaScript/Reference/Operators/this">this</a></code></li>
</ul>
