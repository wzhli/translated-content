---
title: 'Array.prototype[@@unscopables]'
slug: Web/JavaScript/Reference/Global_Objects/Array/@@unscopables
tags:
  - ECMAScript 2015
  - JavaScript
  - Property
  - Prototype
  - Массив
translation_of: Web/JavaScript/Reference/Global_Objects/Array/@@unscopables
---
<div>{{JSRef}}</div>

<p>Свойства символа <code><strong>@@unscopable</strong></code> содержат свойства имён, которые не были включены в ECMAScript до версии ES2015. Эти свойства исключены из привязок оператора <code><a href="/en-US/docs/Web/JavaScript/Reference/Statements/with">with</a></code>.</p>

<h2 id="Синтаксис">Синтаксис</h2>

<pre class="syntaxbox"><var>arr</var>[Symbol.unscopables]</pre>

<h2 id="Описание">Описание</h2>

<p>Стандартные свойства массива, которые исключены из привязок  <code>with</code>: copyWithin, entries, fill, find, findIndex, includes, keys, и values.</p>

<p>См. {{jsxref("Symbol.unscopables")}} о том, как установить <code>unscopables</code> для ваших собственных объектов.</p>

<p>{{js_property_attributes(0,0,1)}}</p>

<h2 id="Примеры">Примеры</h2>

<p>Приведённый код отлично работает в ES5 и ниже. Однако в ECMAScript 2015 и более поздних версиях был введён метод  {{jsxref("Array.prototype.keys()")}}. Это означает, что внутри окружения <code>with</code>, "ключи" будут методом, а не переменной. Вот где теперь встроенные свойства символа {{jsxref("Array.prototype[@@unscopables]")}} вступают в игру и препятствуют тому, чтобы некоторые из методов Array были включены в оператор <code>with</code>.</p>

<pre class="brush: js">var keys = [];

with (Array.prototype) {
  keys.push('что-то');
}

Object.keys(Array.prototype[Symbol.unscopables]);
// ["copyWithin", "entries", "fill", "find", "findIndex",
//  "includes", "keys", "values"]</pre>

<h2 id="Спецификации">Спецификации</h2>

{{Specifications}}

<h2 id="Совместимость_с_браузерами">Совместимость с браузерами</h2>

<div>
<p>{{Compat}}</p>
</div>

<h2 id="Смотрите_также">Смотрите также</h2>

<ul>
 <li>{{jsxref("Symbol.unscopables")}}</li>
</ul>
