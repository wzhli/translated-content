---
title: Кодеки, используемые WebRTC
slug: Web/Media/Formats/WebRTC_codecs
tags:
  - Кодеки WebRTC
translation_of: Web/Media/Formats/WebRTC_codecs
original_slug: Web/Media/Formats/WebRTC_кодеки
---
<div>{{QuickLinksWithSubpages("/en-US/docs/Web/Media")}}</div>

<p>С <a href="/en-US/docs/Web/API/WebRTC_API">WebRTC API</a> возможно создание сайтов и приложений, позволяющих пользователям общаться в реальном времени, используя аудио и/или видео, а также передавать данные или другую информацию. Для общения, двум устройствам необходима возможность согласования использования кодеков, для каждой дорожки в потоке данных, для успешного взаимодействия и обмена медиаданными. В этом руководстве рассматриваются кодеки, которые требуются браузерам для этого, а также другие кодеки, которые поддерживаются некоторыми или всеми браузерами, поддерживающими <span class="seoSummary">WebRTC.</span></p>

<h2 id="Безконтейнерные_медиаданные">Безконтейнерные медиаданные</h2>

<p>WebRTC использует объект типа {{domxref("MediaStreamTrack")}} для представления каждого трека, передающегося между узлами соединения без использования контейнера или объекта типа {{domxref("MediaStream")}} , объединяющего треки. Какие кодеки могут быть в этих треках, спецификацией  WebRTC не определяется. Однако, {{RFC(7742)}} определяет, что все браузеры, поддерживающие WebRTC, должны поддерживать <a href="/en-US/docs/Web/Media/Formats/Video_codecs#VP8">VP8</a> и <a href="/en-US/docs/Web/Media/Formats/Video_codecs#AVC_(H.264)">H.264</a> ограниченный базовый профиль для видео; и {{RFC(7874)}} , определяющая, что браузеры должны поддерживать, по меньшей мере, кодеки <a href="/en-US/docs/Web/Media/Formats/Audio_codecs#Opus">Opus</a> и <a href="/en-US/docs/Web/Media/Formats/Audio_codecs#G.711">G.711</a>  форматов PCMA и PCMU.</p>

<p>Эти две спецификации определяют свойства, которые должны поддерживаться каждым кодеком, а так же определённые функции для удобства использования, к примеру, функция эхоподавления. В этом руководстве происходит обзор кодеков, поддержка которых обязательна браузерам для реализации WebRTC, а так же иные (не обязательные) кодеки, поддерживаемые отдельными или всеми браузерами,.</p>

<p>Хоть сжатие всегда и необходимо при работе со средствами массовой информации в Интернете, оно имеет дополнительное значение при проведении видеоконференций, чтобы участники могли общаться без задержек и перерывов. Второстепенное значение имеет необходимость синхронизации видео и звука, чтобы движения и любая вспомогательная информация (например, слайды или проекция) были представлены одновременно с соответствующим звуком</p>

<h2 id="Общие_требования_к_кодекам">Общие требования к кодекам</h2>

<p>Прежде чем рассматривать возможности и требования, специфичные для кодеков, необходимо выполнить несколько общих требований, которые должны быть выполнены при любой конфигурации кодеков, используемой с WebRTC</p>

<p>Если {{Glossary ("SDP")}} специально не указывает иное, веб-браузер, принимающий видеопоток WebRTC, должен иметь возможность обрабатывать видео со скоростью не менее 20 кадров в секунду при минимальном разрешении 320 пикселей в ширину и 240 пикселей в высоту. Рекомендуется, чтобы видео кодировалось с частотой кадров и размером не ниже этого, поскольку это, по сути, нижняя граница того, что WebRTC обычно должен обрабатывать.</p>

<p>SDP поддерживает независимый от кодеков способ указания предпочтительных разрешений видео ({{RFC (6236)}}). Это делается путём отправки <code>a=imageattr</code> атрибута SDP для указания максимально допустимого разрешения. Однако отправителю не требуется поддерживать этот механизм, поэтому вы должны быть готовы получать носители с другим разрешением, чем вы запрашивали. Помимо этого простого запроса максимального разрешения, определённые кодеки могут предлагать дополнительные способы запроса конкретных конфигураций мультимедиа.</p>

<h2 id="Поддерживаемые_видео_кодеки">Поддерживаемые видео кодеки</h2>

<p>WebRTC устанавливает набор базовых кодеков, которые требуются браузерам для работы. Некоторые браузеры могут поддерживать дополнительный набор кодеков.</p>

<p>Ниже приведены видеокодеки, которые требуются в любом полностью совместимом с WebRTC браузере, а также требуемые профили и браузеры, которые фактически соответствуют требованиям</p>

<table class="standard-table">
 <caption>
 <p>Обязательные видеокодеки</p>
 </caption>
 <thead>
  <tr>
   <th scope="row">Наименование кодека</th>
   <th scope="col">Профиль</th>
   <th scope="col">Совместимость с браузерами</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <th scope="row">{{anch("VP8")}}</th>
   <td>—</td>
   <td>Chrome, Edge, Firefox, Safari (12.1+)</td>
  </tr>
  <tr>
   <th scope="row">{{anch("AVC", "AVC / H.264")}}</th>
   <td>Constrained Baseline (CB)</td>
   <td>Chrome (52+), Edge, Firefox<sup><a href="#supported-foot-1">[1]</a></sup>, Safari</td>
  </tr>
 </tbody>
</table>

<p><a name="supported-foot-1">[1]</a>  Firefox для Android 68 и более поздних версий больше не поддерживает AVC (H.264). Это связано с изменением требований магазина Google Play, которые не позволяют Firefox загружать и устанавливать кодек OpenH264, необходимый для обработки H.264 в соединениях WebRTC. Смотрим подробности в <a href="https://support.mozilla.org/en-US/kb/firefox-android-openh264"> статье о SUMO</a> .</p>

<p>Для получения дополнительной информации о соображениях, связанных с WebRTC для каждого кодека, см. Подразделы ниже, перейдя по ссылкам на название каждого кодека.</p>

<p>Полную информацию о том, какие видеокодеки и конфигурации требуется для поддержки WebRTC, можно найти в {{RFC (7742, "Требования к обработке видео и кодекам WebRTC")}}. Стоит отметить, что RFC охватывает множество требований, связанных с видео, включая цветовые пространства (sRGB является предпочтительным, но не обязательным цветовым пространством по умолчанию), рекомендации по функциям обработки веб-камеры (автоматическая фокусировка, автоматический баланс белого, автоматический уровень освещения) и так далее.</p>

<div class="blockIndicator note">
<p><strong> Предупреждение :</strong>  Эти требования относятся к веб-браузерам и другим продуктам, полностью совместимым с WebRTC. Продукты, не относящиеся к WebRTC, которые в некоторой степени могут взаимодействовать с WebRTC, могут поддерживать или не поддерживать эти кодеки, хотя это рекомендуется в технических документах</p>
</div>

<p>В дополнение к обязательным кодекам, некоторые браузеры также поддерживают дополнительные кодеки. Они перечислены в таблице ниже</p>

<table class="standard-table">
 <caption>
 <p>Другие видео кодеки</p>
 </caption>
 <thead>
  <tr>
   <th scope="row">Наименование кодека</th>
   <th scope="col">Профили</th>
   <th scope="col">Совместимость с браузерами</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <th scope="row">VP9</th>
   <td>—</td>
   <td>Chrome (48+), Firefox</td>
  </tr>
 </tbody>
</table>

<h3 id="Кодек_VP8">Кодек VP8</h3>

<p>VP8, который мы  <a href="/en-US/docs/Web/Media/Formats/Video_codecs#VP8">описывали в общем</a>  в основной статье  <a href="/en-US/docs/Web/Media/Formats/Video_codecs">руководства по сетевым видеокодекам</a>, имеет специфические требования, которым необходимо следовать при кодировании видео треков WebRTC соединения.</p>

<p>По умолчанию, VP8 будет использовать квадратные пиксели (то есть, пиксели с соотношением сторон 1: 1).</p>

<h4 id="Дополнительное_замечание">Дополнительное замечание</h4>

<p>Формат полезной нагрузки сети для совместного использования VP8 с помощью {{Glossary("RTP")}} (например, при использовании WebRTC) описано в {{RFC(7741, "RTP Payload Format for VP8 Video")}}.</p>

<h3 id="Кодек_AVC_H.264"><a id="AVC"> Кодек AVC / H.264</a></h3>

<p>Поддержка профиля AVC Constrained Baseline (<code>CB</code>) требуется во всех полностью совместимых реализациях WebRTC. <code>CB</code> является подмножеством основного профиля и специально разработан для приложений с низкой сложностью и малой задержкой, таких как мобильное видео и видеоконференции, а также для платформ с более низкими возможностями обработки видео..</p>

<p>Наш <a href="/en-US/docs/Web/Media/Formats/Video_codecs#AVC_(H.264)">обзор  AVC</a> и его функциональности найдёте в основном руководстве по видеокодекам.</p>

<h4 id="Требования_поддержки_специальных_параметров">Требования поддержки специальных параметров</h4>

<p>AVC предлагает широкий спектр параметров для управления дополнительными значениями. Чтобы повысить надёжность совместного использования мультимедиа WebRTC на нескольких платформах и в разных браузерах, необходимо, чтобы конечные точки WebRTC, поддерживающие AVC, обрабатывали определённые параметры определённым образом. Иногда это просто означает, что параметр должен (или не должен) поддерживаться. Иногда это означает, что необходимо указать конкретное значение для параметра или разрешить определённый набор значений. А иногда требования более сложны.</p>

<h5 id="Полезные_но_необязательные_параметры">Полезные, но необязательные параметры</h5>

<p>Эти параметры не обязаны поддерживаться конечной точкой WebRTC, и их использование также не обязательно. Их использование, некоторым образом, может улучшить пользовательское впечатление , но к использованию не обязательно. Некоторые из них довольно сложны в использовании.</p>

<dl>
 <dt><code>max-br</code></dt>
 <dd>Если параметр определён и поддерживается , он определяет максимальную скорость передачи видеоданных в  единицах 1,000 bps (бит в секунду) для VCL и 1,200 bps (бит в секунду) для NAL. Подробности на  <a href="https://tools.ietf.org/html/rfc6184#page-47">странице 47 спецификации RFC 6184</a>.</dd>
 <dt><code>max-cpb</code></dt>
 <dd>Если параметр определён и поддерживается, он определяет максимальный размер буфера, кодируемых данных. Немного усложнённый параметр, размер которого может варьироваться. Смотрим на <a href="https://tools.ietf.org/html/rfc6184#page-45">страницу  45 спецификации RFC 6184</a> о подробностях.</dd>
 <dt><code>max-dpb</code></dt>
 <dd>Определяет максимальный размер буфера  декодированных данных, выраженных в единицах  8/3 макроблоков. Подробности в спецификации <a href="https://tools.ietf.org/html/rfc6184#page-46">RFC 6184, страница 46</a>.</dd>
 <dt><code>max-fs</code></dt>
 <dd>Определяет максимальный размер видеокадра, выраженный в количестве макроблоков.</dd>
 <dt><code>max-mbps</code></dt>
 <dd>Определяет максимальную скорость обработки макроблоков в секунду. Значение является целым числом..</dd>
 <dt><code>max-smbps</code></dt>
 <dd>Определяет максимальную скорость обработки статических макроблоков в секунду (используя гипотетическое предположение, что все макроблоки являются статическими макроблоками).</dd>
</dl>

<h5 id="Параметры_с_определёнными_требованиями">Параметры с определёнными требованиями</h5>

<p>Эти параметры являются необязательными, но имеют специальные требования при их использовании.</p>

<dl>
 <dt><code>packetization-mode</code></dt>
 <dd>Все конечные точки обязательны для поддержания режима  1 (не чередующийся режим). Поддержка иных режимов пакетизации не обязательна, и сам параметр не обязателен для определения.</dd>
 <dt><code>sprop-parameter-sets</code></dt>
 <dd>Информация о последовательности и изображении для AVC может передаваться как внутри канала, так и вне его. При использовании AVC  с WebRTC, информация должна передаваться в канале, поэтому значение параметра не включается в SDP.</dd>
</dl>

<h5 id="Обязательные_для_определения_параметры">Обязательные для определения параметры</h5>

<p>Эти параметры обязательны к определению, при использовании AVC в WebRTC соединении.</p>

<dl>
 <dt><code>profile-level-id</code></dt>
</dl>

<p>Все реализации WebRTC обязательно определяют и передают  в своих  SDP, определяя суб  - профиль используемого кодека (подмножество инструментов кодирования, которые могут быть использованы для генерации потока или того, что поддерживает получатель) и уровня потока по умолчанию, или уровня поддержки получателя.</p>

<p> Конкретное значение разработчику не известно, используется одно на всех, и устанавливается  WebRTC. Начиная с {{RFC(6184)}} ("RTP Payload Format for H.264 Video"), наличие <code>profile-level-id</code> необязательно.</p>

<h4 id="Прочие_требования">Прочие требования</h4>

<p>В целях поддержки переключения между книжной и альбомной ориентацией можно использовать два метода. Первый - это расширение заголовка видеоориентации (CVO) для протокола RTP. Однако, если это не сигнализируется как поддерживаемое в SDP, тогда рекомендуется, чтобы браузеры поддерживали сообщения Display Orientation SEI, хотя и не обязательно</p>

<p>Если не указано иное, соотношение сторон пикселя составляет 1: 1, что указывает на то, что пиксели являются квадратными</p>

<h4 id="Прочие_замечания">Прочие замечания</h4>

<p>Формат полезной нагрузки, используемый для AVC в WebRTC, описан в {{RFC(6184, "RTP Payload Format for H.264 Video")}}. Реализации AVC для WebRTC необходимы для поддержки специальных сообщений SEI :  «заполнитель нагрузки» и «полное замораживание кадра», они используются для плавного переключения между несколькими входными потоками.</p>

<h2 id="Поддерживаемые_аудио_кодеки">Поддерживаемые аудио кодеки</h2>

<p>Спецификация  {{RFC(7874)}} предписывает всем браузерам поддержку аудиокодеков, перечисленных в таблице :</p>

<table class="standard-table">
 <caption>
 <p>Обязательные аудиокодеки</p>
 </caption>
 <thead>
  <tr>
   <th scope="row">Наименование кодека</th>
   <th scope="col">Совместимость с браузерами</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <th scope="row"><a href="/en-US/docs/Web/Media/Formats/Audio_codecs#Opus">Opus</a></th>
   <td>Edge, Firefox, Safari</td>
  </tr>
  <tr>
   <th scope="row"><a href="/en-US/docs/Web/Media/Formats/Audio_codecs#G.711">G.711 PCM (A-law)</a></th>
   <td>Chrome, Firefox, Safari</td>
  </tr>
  <tr>
   <th scope="row"><a href="/en-US/docs/Web/Media/Formats/Audio_codecs#G.711">G.711 PCM (µ-law)</a></th>
   <td>Chrome, Firefox, Safari</td>
  </tr>
 </tbody>
</table>

<p>Более подробное обсуждение использования кодеков в WebRTC следует ниже.</p>

<p>Спецификация  {{RFC(7874)}} определяет список аудио кодеков, которые браузеры, реализующие WebRTC обязаны поддерживать; так же предоставляются рекомендации и требования для специфических аудио функциональностей, таких как удаление эхоподавление, шумоподавление и выравнивание звука.</p>

<div class="blockIndicator note">
<p><strong> Примечание :</strong>  Список выше указывает на минимальный набор кодеков, который требуется реализовать браузерам (браузерному окружению), поддерживающих  WebRTC. Такие браузеры могут поддерживать также и другие кодеки, что подвергает риску межплатформенной совместимости при использовании этих кодеков без проверки гарантированной работоспособности в часто используемых браузерах.</p>
</div>

<p>В дополнение к обязательным видеокодекам, некоторые браузеры поддерживают дополнительные кодеки, перечисленные в таблице:</p>

<table class="standard-table">
 <caption>Дополнительные аудио кодеки</caption>
 <thead>
  <tr>
   <th scope="row">Наименование кодека</th>
   <th scope="col">Совместимость с браузерами</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <th scope="row">G.722</th>
   <td>Chrome, Firefox, Safari</td>
  </tr>
  <tr>
   <th scope="row">iLBC<sup><a href="#other-audio-foot-1">[1]</a></sup></th>
   <td>Chrome, Safari</td>
  </tr>
  <tr>
   <th scope="row">iSAC<sup><a href="#other-audio-foot-2">[2]</a></sup></th>
   <td>Chrome, Safari</td>
  </tr>
 </tbody>
</table>

<p><a id="other-audio-foot-1" name="other-audio-foot-1">[1]</a> <strong>{{interwiki("wikipedia", "Internet Low Bitrate Codec")}}</strong> (<strong>iLBC</strong>)  - узкополосный кодек с открытым кодом, разработанный Global IP Solutions и Google, спроектированный для потокового голосового аудио. Google и другие разработчики браузеров адоптировали его для работы с  WebRTC, но он доступен не во всех браузерах, и не является обязательно поддерживаемым кодеком.</p>

<p><a id="other-audio-foot-2" name="other-audio-foot-2">[2]</a> The <strong>{{interwiki("wikipedia", "Internet Speech Audio Codec")}}</strong> (<strong>iSAC</strong>)  -  другой кодек, разработанный Global IP Solutions, теперь принадлежащий Google, открывший его код. Используется Google Talk, QQ, и другими клиентами быстрых сообщений, специально спроектированный для голосовых сообщений, упакованных в поток RTP. Пока не является обязательной поддерживаемым кодеком. Поддерживается Safari и Chrome. Не поддерживается Firefox и Edge.</p>

<p><strong>{{interwiki("wikipedia", "Comfort noise")}}</strong> (<strong>CN</strong>) - комфортный шум. Является формой искусственного фонового шума, использующегося для заполнения пробелов в передаче, вместо использования полной тишины. Помогает избежать вибрационных эффектов, возникающих, когда голосовая активация или подобная функциональность  вызывает временное приостановление потока, известная как прерывистая передача (Discontinuous Transmission (DTX)). В спецификации {{RFC(3389)}}, метод предлагает использовать определённое заполнение в беззвучных промежутках.</p>

<p>Комфортный шум используется с G.711 и может потенциально использоваться с другими кодеками, которые не имеют встроенной функции CN. Кодек Opus, к примеру, имеет собственную реализацию CN, поэтому использование RFC 3389 CN с кодеком Opus не рекомендуется.</p>

<p>Отправитель звука никогда не должен использовать прерывистую передачу или комфортный шум.</p>

<h3 id="Кодек_Opus">Кодек Opus</h3>

<p>Формат Opus, определённый в {{RFC (6716)}}), является основным форматом для аудио в WebRTC. Формат полезной нагрузки RTP для Opus находится в {{RFC (7587)}}. Можете найти подробную информацию об Opus и его возможностях, а также о том, как другие API могут поддерживать Opus, в <a href="/en-US/docs/Web/Media/Formats/Audio_codecs#Opus">соответствующей секции</a>  нашего <a href="/en-US/docs/Web/Media/Formats/Audio_codecs">руководства по аудиокодекам, использующимся в web</a>.</p>

<p>Должны поддерживаться оба режима : речь и обычное аудио. Масштабируемость и гибкость Opus полезна при работе с аудио, имеющим различную степень сложности. Поддержка внутриполосных стереосигналов позволяет поддерживать стереозвук без усложнения процесса демультиплексирования.</p>

<p>Весь диапазон битрейтов, поддерживаемых Opus (от 6 кбит / с до 510 кбит / с), поддерживается в WebRTC, причём скорость битов можно динамически изменять. Более высокие битовые скорости передачи обычно улучшают качество..</p>

<h4 id="Рекомендации_по_скорости_передачи_данных_bit_rate">Рекомендации по скорости передачи данных (bit rate)</h4>

<p>При условии размер кадра в 20 миллисекунд, в следующей таблице приведены рекомендуемые скорости передачи данных для различных типов носителей.</p>

<table class="standard-table">
 <thead>
  <tr>
   <th scope="col">Медиа носитель</th>
   <th scope="col">Рекомендованный диапазон bit rate</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <td>Узкополосная речь (NB)</td>
   <td>8 - 12 kbps</td>
  </tr>
  <tr>
   <td>Широкополосная речь (WB)</td>
   <td>16 - 20 kbps</td>
  </tr>
  <tr>
   <td>Полноценная речь (FB)</td>
   <td>28 - 40 kbps</td>
  </tr>
  <tr>
   <td>Монофоническая музыка (FB mono)</td>
   <td>48 - 64 kbps</td>
  </tr>
  <tr>
   <td>Стереофоническая музыка (FB stereo)</td>
   <td>64 - 128 kbps</td>
  </tr>
 </tbody>
</table>

<p>Скорость передачи может быть скорректирована в любое время. Во избежание перегрузки сети средняя скорость передачи звука не должна превышать доступную пропускную способность сети (за вычетом любых других известных или ожидаемых дополнительных требований к пропускной способности).</p>

<h3 id="Кодек_G.711">Кодек G.711</h3>

<p>G.711 определяет формат для звука с импульсной кодовой модуляцией (PCM) в виде серии 8-битных целочисленных выборок, взятых с частотой дискретизации 8000 Гц, что даёт скорость передачи данных 64 кбит / с. И в {{interwiki("wikipedia", "M-law", "µ-law")}} , и в {{interwiki("wikipedia", "A-law")}} разрешена кодировка.</p>

<p>G.711 <a href="https://www.itu.int/rec/T-REC-G.711-198811-I/en">определяется ITU</a>  , а его формат нагрузки в {{RFC(3551, "4.5.14")}}.</p>

<p>WebRTC требует, чтобы G.711 использовал 8-битные выборки со стандартной скоростью 64 кбит / с, хотя G.711 поддерживает некоторые другие варианты. WebRTC не предписывает использовать ни G.711.0 (сжатие без потерь), G.711.1 (широкополосная возможность), ни какие-либо другие расширения стандарта G.711</p>

<p>Из-за низкой частоты дискретизации и размера выборки качество звука G.711 в целом считается низким по современным стандартам, хотя оно примерно эквивалентно звучанию стационарного телефона. Обычно он используется в качестве наименьшего общего знаменателя, чтобы гарантировать, что браузеры могут установить аудио-соединение независимо от платформ и браузеров, или как запасной вариант в целом.</p>

<h2 id="Определение_и_конфигурирование_кодеков">Определение и конфигурирование кодеков</h2>

<h3 id="Получение_поддерживаемых_кодеков">Получение поддерживаемых кодеков</h3>

<p>Поскольку браузер и платформа могут иметь различную доступность среди потенциальных кодеков - и могут иметь несколько профилей или уровней, поддерживаемых для данного кодека - первый шаг при настройке кодеков для объекта типа {{domxref("RTCPeerConnection")}}  - получить список доступных кодеков. Для этого сначала нужно инициализировать объект соединения, который получит список.</p>

<p>Существует два способа для выполнения этого. Наиболее эффективный - использовать статический метод {{domxref("RTCRtpSender.getCapabilities()")}} (или эквивалентный для принимающего узла {{domxref("RTCRtpReceiver.getCapabilities()")}} ), определяющий тип медиаданных в параметре. К примеру, для определения поддерживаемых кодеков видео применяем :</p>

<pre class="brush: js">codecList = RTCRtpSender.getCapabilities("video").codecs;</pre>

<p>Теперь массив <code>codecList</code> содержит объекты {{domxref("RTCRtpCodecCapability")}} , каждый содержащий описываемую конфигурацию кодека. Также в списке будут присутствовать записи для повторной передачи (RTX), избыточного кодирования (RED) и прямого исправления ошибок (FEC).</p>

<p>Если соединение находится в процессе запуска, используем событие {{domxref("RTCPeerConnection.icegatheringstatechange_event", "icegatheringstatechange")}}  для наблюдения за изменением статуса сборки кандидатов  {{Glossary("ICE")}} и при завершении, запрашиваем список кодеков.</p>

<pre class="brush: js">let codecList = null;

peerConnection.addEventListener("icegatheringstatechange", (event) =&gt; {
  if (peerConnection.iceGatheringState === "complete") {
    const senders = peerConnection.getSenders();

    senders.forEach((sender) =&gt; {
      if (sender.track.kind === "video") {
        codecList = sender.getParameters().codecs;
        return;
      }
    });
  }

  codecList = null;
});</pre>

<p>Обработчик события <code>icegatheringstatechange</code> установлен; в нем мы отслеживаем тип события <code>complete</code> завершения сборки кандидатов ICE, указывающее что сборка кандидатов завершена. Метод {{domxref("RTCPeerConnection.getSenders()")}} вызывается для получения списка всех объектов {{domxref("RTCRtpSender")}} , использующихся в соединении.</p>

<p>Имея это в виду, мы просматриваем список отправителей и ищем первого, чей {{domxref ("MediaStreamTrack")}} указывает, что тип {{domxref ("MediaStreamTrack.track", "track")}} в своём свойстве  {{domxref("MediaStreamTrack.kind", "kind")}} содержит значение <code>video</code>, указывающее, что данные являются видеоданными. Затем вызывается метод отправителя  {{domxref("RTCRtpSender.getParameters", "getParameters()")}} , и значением свойства  {{domxref("RTCRtpParameters.codecs", "codecs")}} возвращаемого объекта {{domxref("RTCRtpSendParameters")}} , инициализируем переменную <code>codecList</code>.</p>

<p>Если видеотрек не найден, устанавливаем  <code>codecList</code> в <code>null</code>.</p>

<p>При возврате, <code>codecList </code>либо  <code>null</code> , указывающий на то, что видеодорожки не были найдены, либо это массив {{domxref ("RTCRtpCodecParameters")}} объектов, каждый из которых описывает одну разрешённую конфигурацию кодека. Особое значение в этих объектах имеет свойство {{domxref ("RTCRtpCodecParameters.payloadType", "payloadType")}}, которое является однобайтовым значением, однозначно идентифицирующим описанную конфигурацию.</p>

<div class="blockIndicator note">
<p><strong>Примечание :</strong>  Два метода получения списков кодеков, показанные здесь, используют разные типы вывода в своих списках кодеков. Помните об этом при использовании результатов</p>
</div>

<h3 id="Настройка_списка_кодеков">Настройка списка кодеков</h3>

<p>Как только получен список доступных кодеков, его можно изменить и передать этот пересмотренный список методу  {{domxref("RTCRtpTransceiver.setCodecPreferences()")}} для перенастройки списка, используемых кодеков. Это изменяет порядок предпочтений кодеков, позволяя указать WebRTC на более предпочтительный кодек среди прочих .</p>

<pre class="brush: js">function changeVideoCodec(mimeType) {
  const transceivers = peerConnection.getTransceivers();

  transceivers.forEach(transceiver =&gt; {
    const kind = transceiver.sender.track.kind;
    let sendCodecs = RTCRtpSender.getCapabilities(kind).codecs;
    let recvCodecs = RTCRtpReceiver.getCapabilities(kind).codecs;

    if (kind === "video") {
      sendCodecs = preferCodec(mimeType);
      recvCodecs = preferCodec(mimeType);
      transceiver.setCodecPreferences([...sendCodecs, ...recvCodecs]);
    }
  });

  peerConnection.onnegotiationneeded();
}
</pre>

<p>В этом примере функция  <code>changeVideoCodec()</code> принимает в параметр MIME тип предпочтительного к использованию кодека. Код начинается с получения списка объектов приёмо-передатчиков объекта соединения {{domxref("RTCPeerConnection")}}.</p>

<p>Затем, для каждого приёмо-передатчика анализируем тип медиа свойства {{domxref("RTCRtpSender")}}'s track's {{domxref("MediaStreamTrack.kind", "kind")}}. Так же получаем список поддерживаемых браузером кодеков стороны отправки и получения  <code>video</code>, используя статический метод <code>getCapabilities()</code> обоих классов {{domxref("RTCRtpSender")}} и {{domxref("RTCRtpReceiver")}}.</p>

<p>Если тип медиаданных является типом  <code>video</code>, вызываем метод <code>preferCodec()</code> для обоих взаимодействующих сторон списков кодеков, который реорганизует список кодеков необходимым образом  (смотри ниже).</p>

<p>И наконец, вызываем метод {{domxref("RTCRtpTransceiver.setCodecPreferences", "setCodecPreferences()")}} объекта  {{domxref("RTCRtpTransceiver")}} для определения того, что использование кодеков обеих сторон разрешено, в указанном порядке.</p>

<p>Это выполняется для каждого объекта приёмо-передатчика объекта соединения  <code>RTCPeerConnection</code>; как только все приёмо-передатчики обновили списки предпочитаемых кодеков, вызывается обработчик события  {{domxref("RTCPeerConnection.onnegotiationneeded", "onnegotiationneeded")}} , который создаёт новый объект предложения, обновляет объект локального описания сессии, отправляет предложение удалённому узлу, и так далее, запуская согласование соединения .</p>

<p>Функция <code>preferCodec()</code> вызываемая приведённым выше кодом, действует так, чтобы переместить указанный кодек в верхнюю часть списка (для приоритета во время согласования):</p>

<pre class="brush: js">function preferCodec(codecs, mimeType) {
  let otherCodecs = [];
  let sortedCodecs = [];
  let count = codecs.length;

  codecs.forEach(codec =&gt; {
    if (codec.mimeType === mimeType) {
      sortedCodecs.push(codec);
    } else {
      otherCodecs.push(codec);
    }
  });

  return sortedCodecs.concat(otherCodecs);
}</pre>

<p>Этот код просто разбивает список кодеков на два массива: один, содержащий кодеки, чей  MIME тип совпадает с тем, который указан в параметре <code>mimeType</code> , другой же содержит остальные кодеки. Как только список разделён, они объединяются вместе с записями, соответствующими заданному <code>mimeType</code> следующими вначале, за которыми следуют остальные записи кодеков. Затем этот список возвращается вызывающему коду.</p>

<h2 id="Кодеки_по_умолчанию">Кодеки по умолчанию</h2>

<p>Если не определённо иное, кодеки по умолчанию (предпочтительные кодеки), запрашиваемые браузерными реализациями  WebRTC, перечислены ниже</p>

<table class="standard-table">
 <caption>
 <p>Предпочтительные для  WebRTC кодеки основных веб-браузеров</p>
 </caption>
 <thead>
  <tr>
   <th scope="col"></th>
   <th scope="col">Audio</th>
   <th scope="col">Video</th>
  </tr>
 </thead>
 <tbody>
  <tr>
   <th scope="row">Chrome</th>
   <td></td>
   <td></td>
  </tr>
  <tr>
   <th scope="row">Edge</th>
   <td></td>
   <td></td>
  </tr>
  <tr>
   <th scope="row">Firefox</th>
   <td></td>
   <td>VP9 (Firefox 46 and later)<br>
    VP8</td>
  </tr>
  <tr>
   <th scope="row">Opera</th>
   <td></td>
   <td></td>
  </tr>
  <tr>
   <th scope="row">Safari</th>
   <td></td>
   <td></td>
  </tr>
 </tbody>
</table>

<h2 id="Правильный_выбор_кодеков">Правильный выбор кодеков</h2>

<p>Перед выбором кодека, который не является обязательным (VP8 или AVC для видео и  Opus или PCM для аудио), следует серьёзно рассмотреть потенциальные недостатки: в особенности, если предполагается, что эти кодеки не широко доступны на всех устройствах, поддерживающих WebRTC.</p>

<p>Если вы предпочитаете кодек, отличный от обязательных, вы должны по крайней мере разрешить откат к одному из обязательных кодеков, если поддержка для кодека, который вы предпочитаете, окажется недоступна.</p>

<h3 id="Аудио">Аудио</h3>

<p>В целом, если кодек доступен и звук, который вы хотите отправить, имеет частоту дискретизации более 8 кГц, вам следует настоятельно рекомендовать использовать Opus в качестве основного кодека. Для голосовых соединений в стеснённой среде использование G.711 с частотой дискретизации 8 кГц может обеспечить приемлемое качество для разговора, но обычно вы будете использовать G.711 в качестве запасного варианта, поскольку есть другие более эффективные варианты, чей звук лучше, такие как Опус в своём узкополосном режиме .</p>

<h3 id="Видео">Видео</h3>

<p>При выборе поддерживаемого видеокодека (или набора кодеков) необходимо учитывать ряд факторов</p>

<h4 id="Условия_лицензирования">Условия лицензирования</h4>

<p>Прежде чем выбрать видеокодек, убедитесь, что вы знаете о любых лицензионных требованиях к выбранному вами кодеку; можете найти информацию о возможных проблемах лицензирования в нашем основном <a href="/en-US/docs/Web/Media/Formats/Video_codecs">руководстве по видеокодекам, используемым в  web</a>. Из двух обязательных кодеков для видео - VP8 и AVC / H.264 - только VP8 полностью свободен от лицензионных требований. Если выбираете AVC, убедитесь, что вы знаете о любых возможных сборах, которые вам, возможно, придётся заплатить; владельцы патентов обычно говорят, что большинству типичных разработчиков веб-сайтов не нужно беспокоиться об оплате лицензионных сборов, которые, как правило, больше ориентированы на разработчиков программного обеспечения для кодирования и декодирования.</p>

<div class="blockIndicator warning">
<p><strong>Внимание :</strong>  Информация здесь не является юридической консультацией! Обязательно убедитесь в возможности ответственности, прежде чем принимать какие-либо окончательные решения, если существует вероятность возникновения проблем с лицензированием.</p>
</div>

<h4 id="Энергопотребление_и_срок_службы_батареи">Энергопотребление и срок службы батареи</h4>

<p>Ещё один фактор, который следует учитывать, особенно на мобильных платформах, - это влияние кодека на время автономной работы. Если кодек обрабатывается аппаратно на данной платформе, он, вероятно, позволит значительно увеличить срок службы батареи и уменьшить выработку тепла.</p>

<p>Например, Safari для iOS и iPadOS представила WebRTC с AVC в качестве единственного поддерживаемого видеокодека. Преимущество AVC на iOS и iPadOS заключается в возможности кодирования и декодирования на аппаратном уровне.Safari 12.1 представил поддержку VP8 в IRC, что улучшает взаимодействие, но за дополнительную плату - VP8 не имеет аппаратной поддержки на устройствах iOS, поэтому его использование приводит к увеличению нагрузки на процессор и сокращению срока службы батареи.</p>

<h4 id="Производительность">Производительность</h4>

<p>К счастью, VP8 и AVC работают одинаково с точки зрения конечного пользователя и одинаково адекватны для использования в видеоконференцсвязи и других решениях WebRTC. Окончательное решение остаётся за разработчиком. Какой бы вариант вы ни выбрали, обязательно прочитайте информацию, представленную в этой статье, о любых конкретных проблемах конфигурации, с которыми вам, возможно, придётся столкнуться для этого кодека.</p>

<p>Имейте в виду, что выбор кодека, которого нет в списке обязательных кодеков, может привести к риску выбора кодека, который не поддерживается браузером, который предпочитают ваши пользователи. Прочтите <a href="/en-US/docs/Web/Media/Formats/Support_issues">Решение проблем медиаподдержки в веб контенте</a> , чтобы узнать больше о том, как предлагать поддержку предпочитаемых кодеков, но при этом использовать браузеры, которые не поддерживают этот кодек.</p>

<h2 id="Последствия_для_безопасности">Последствия для безопасности</h2>

<p>При выборе и настройке кодеков возникают интересные потенциальные проблемы безопасности. Видео WebRTC защищено с помощью Datagram Transport Layer Security ({{Glossary("DTLS")}}), но для мотивированной стороны теоретически возможно вывести величину изменения, которое происходит от кадра к кадру при использовании кодеков с переменной скоростью передачи (VBR), путём мониторинга скорости потока  и её изменения во времени.Это может потенциально позволить злоумышленнику сделать вывод о содержании потока, учитывая приливы и отливы скорости передачи.</p>

<p>Подробнее о безопасности при использовании AVC в WebRTC см.  {{RFC(6184, "RTP Payload Format for H.264 Video: Security Considerations", 9)}}.</p>

<h2 id="Смотрите_также">Смотрите также :</h2>

<ul>
 <li><a href="/en-US/docs/Web/API/WebRTC_API">WebRTC API</a></li>
 <li><a href="/en-US/docs/Web/API/WebRTC_API/Protocols">Введение в протоколы WebRTC</a></li>
 <li><a href="/en-US/docs/Web/API/WebRTC_API/Connectivity">WebRTC соединение </a></li>
 <li><a href="/en-US/docs/Web/Media/Formats/Video_codecs">Руководство по видеокодекам, использующимся в web</a></li>
 <li><a href="/en-US/docs/Web/Media/Formats/Audio_codecs">Руководство по аудиокодекам, использующимся в web</a></li>
 <li><a href="/en-US/docs/Web/Media/Formats/Video_concepts">Концепции цифрового видео</a></li>
 <li><a href="/en-US/docs/Web/Media/Formats/Audio_concepts">Концепции цифрового аудио</a></li>
</ul>
