---
title: XMLHttpRequest
slug: Web/API/XMLHttpRequest
tags:
  - AJAX
  - API
  - HTTP
  - JavaScript
  - MakeBrowserAgnostic
  - NeedsMobileBrowserCompatibility
  - NeedsTranslation
  - Reference
  - Référence(2)
  - TopicStub
  - XMLHttpRequest
translation_of: Web/API/XMLHttpRequest
---
<p>{{APIRef("XMLHttpRequest")}}</p>

<p><code>XMLHttpRequest</code> это API, который предоставляет клиенту функциональность для обмена данными между клиентом и сервером. Данный API предоставляет простой способ получения данных по ссылке без перезагрузки страницы. Это позволяет обновлять только часть веб-страницы не прерывая пользователя.  <code>XMLHttpRequest используется в AJAX запросах и особенно в single-page приложениях.</code></p>

<p>XMLHttpRequest изначально был разработан Microsoft и позже заимствован Mozilla, Apple, и Google. Сейчас он <a href="https://xhr.spec.whatwg.org/">стандартизирован WHATWG</a>. Несмотря на своё название, <code>XMLHttpRequest</code> может быть использован для получения любых типов данных, не только XML, и поддерживает протоколы помимо <a href="https://developer.mozilla.org/ru/docs/Web/HTTP">HTTP</a> (включая <code>file</code> и <a href="https://developer.mozilla.org/ru/docs/Glossary/FTP">ftp</a>).</p>

<p>Чтобы начать работать с <code>XMLHttpRequest</code>, выполните этот код:</p>

<pre>var myRequest = new XMLHttpRequest();
</pre>

<p>более детальное описание создание объекта, можно увидеть в разделе <a class="internal" href="/ru/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest" title="En/Using XMLHttpRequest">Using XMLHttpRequest</a>.</p>

<h2 id="Список_методов_объекта">Список методов объекта</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <td><code><a class="internal" href="/en/DOM/XMLHttpRequest#XMLHttpRequest()" title="/en/DOM/XMLHttpRequest#XMLHttpRequest()">XMLHttpRequest</a>(JSObject objParameters);</code></td>
  </tr>
  <tr>
   <td><code>void <a class="internal" href="/en/DOM/XMLHttpRequest#abort()" title="en/DOM/XMLHttpRequest#abort()">abort</a>();</code></td>
  </tr>
  <tr>
   <td><code>DOMString <a class="internal" href="/en/DOM/XMLHttpRequest#getAllResponseHeaders()" title="en/DOM/XMLHttpRequest#getAllResponseHeaders()">getAllResponseHeaders</a>();</code></td>
  </tr>
  <tr>
   <td><code>DOMString? <a class="internal" href="/en/DOM/XMLHttpRequest#getResponseHeader()" title="en/DOM/XMLHttpRequest#getResponseHeader()">getResponseHeader</a>(DOMString header);</code></td>
  </tr>
  <tr>
   <td><code>void <a class="internal" href="/en/DOM/XMLHttpRequest#open()" title="en/DOM/XMLHttpRequest#open()">open</a>(DOMString method, DOMString url, optional boolean async, optional DOMString? user, optional DOMString? password);</code></td>
  </tr>
  <tr>
   <td><code>void <a class="internal" href="/en/DOM/XMLHttpRequest#overrideMimeType()" title="en/DOM/XMLHttpRequest#overrideMimeType()">overrideMimeType</a>(DOMString mime);</code></td>
  </tr>
  <tr>
   <td><code>void <a class="internal" href="/en/DOM/XMLHttpRequest#send()" title="en/DOM/XMLHttpRequest#send()">send</a>();</code><br>
    <s><code>void <a class="internal" href="/en/DOM/XMLHttpRequest#send()" title="en/DOM/XMLHttpRequest#send()">send</a>(ArrayBuffer data);</code></s><br>
    <code>void <a class="internal" href="/en/DOM/XMLHttpRequest#send()" title="en/DOM/XMLHttpRequest#send()">send</a>(ArrayBufferView data);</code><br>
    <code>void <a class="internal" href="/en/DOM/XMLHttpRequest#send()" title="en/DOM/XMLHttpRequest#send()">send</a>(Blob data);</code><br>
    <code>void <a class="internal" href="/en/DOM/XMLHttpRequest#send()" title="en/DOM/XMLHttpRequest#send()">send</a>(Document data);</code><br>
    <code>void <a class="internal" href="/en/DOM/XMLHttpRequest#send()" title="en/DOM/XMLHttpRequest#send()">send</a>(DOMString? data);</code><br>
    <code>void <a class="internal" href="/en/DOM/XMLHttpRequest#send()" title="en/DOM/XMLHttpRequest#send()">send</a>(FormData data);</code></td>
  </tr>
  <tr>
   <td><code>void <a class="internal" href="/en/DOM/XMLHttpRequest#setRequestHeader()" title="en/DOM/XMLHttpRequest#setRequestHeader()">setRequestHeader</a>(DOMString header, DOMString value);</code></td>
  </tr>
  <tr>
   <th>Нестандартные методы</th>
  </tr>
  <tr>
   <td><code>[noscript] void <a class="internal" href="/en/DOM/XMLHttpRequest#init()" title="en/DOM/XMLHttpRequest#init()">init</a>(in nsIPrincipal principal, in nsIScriptContext scriptContext, in nsPIDOMWindow ownerWindow);</code></td>
  </tr>
  <tr>
   <td><code>[noscript] void <a class="internal" href="/en/DOM/XMLHttpRequest#openRequest()" title="en/DOM/XMLHttpRequest#openRequest()">openRequest</a>(in AUTF8String method, in AUTF8String url, in boolean async, in AString user, in AString password); </code></td>
  </tr>
  <tr>
   <td><code>void <a class="internal" href="/en/DOM/XMLHttpRequest#sendAsBinary()" title="en/DOM/XMLHttpRequest#sendAsBinary()">sendAsBinary</a>(in DOMString body);</code> {{ deprecated_inline(31) }}</td>
  </tr>
 </tbody>
</table>

<h2 id="Поля_объекта">Поля объекта</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th>Attribute</th>
   <th>Type</th>
   <th>Description</th>
  </tr>
  <tr id="onreadystatechange">
   <td>
    <p><code>onreadystatechange</code></p>
   </td>
   <td><code>Function?</code></td>
   <td>
    <p>Callback - функция, которая вызывается всякий раз, когда поле <code>readyState меняет своё значение</code>. Callback выполняется в потоке работы приложения.</p>

    <div class="warning"><strong>Внимание:</strong> Он не должен использоваться в синхронных запросах, и не должен выполняться из нативного кода (? must not be used from native code).</div>
   </td>
  </tr>
  <tr id="readyState">
   <td><code>readyState</code></td>
   <td><code>unsigned short</code></td>
   <td>
    <p>Состояние запроса:</p>

    <table class="standard-table">
     <tbody>
      <tr>
       <td class="header">Значение</td>
       <td class="header">Состояние</td>
       <td class="header">Описание</td>
      </tr>
      <tr>
       <td><code>0</code></td>
       <td><code>UNSENT</code></td>
       <td>Клиент создан. Метод <code>open()</code> ещё не вызван.</td>
      </tr>
      <tr>
       <td><code>1</code></td>
       <td><code>OPENED</code></td>
       <td>Вызван метод open<code>()</code>. В этом состоянии можно добавить заголовки через метод <code>setRequestHeader()</code>; вызов метода <code>send()</code> отправит запрос.</td>
      </tr>
      <tr>
       <td><code>2</code></td>
       <td><code>HEADERS_RECEIVED</code></td>
       <td>Вызван метод <code>send()</code>, получены заголовки и код ответа (200, 404, 501 и проч.).</td>
      </tr>
      <tr>
       <td><code>3</code></td>
       <td><code>LOADING</code></td>
       <td>Загрузка; если значение <code>responseType</code> равно "text" или пустой строке, то <code>responseText</code> содержит частичные данные.</td>
      </tr>
      <tr>
       <td><code>4</code></td>
       <td><code>DONE</code></td>
       <td>Операция завершена. Все данные получены.</td>
      </tr>
     </tbody>
    </table>
   </td>
  </tr>
  <tr id="response">
   <td><code>response</code></td>
   <td>varies</td>
   <td>
    <p>Тело сущности запроса. Согласно полю <code><a href="#responseType">responseType</a></code>, может быть <a href="/en/JavaScript_typed_arrays/ArrayBuffer" title="en/JavaScript typed arrays/ArrayBuffer"><code>ArrayBuffer</code></a>, <a href="/en/DOM/Blob" title="en/DOM/Blob"><code>Blob</code></a>, {{ domxref("Document") }}, JavaScript объектом (для "json"), или строкой. Равно <code>null</code> если запрос не завершён или окончен с ошибкой.</p>
   </td>
  </tr>
  <tr id="responseText">
   <td><code>responseText</code> {{ReadOnlyInline()}}</td>
   <td><code>DOMString</code></td>
   <td>Ответ на запрос в виде строки или <code>null</code> в случае если запрос не успешен или ответ ещё не получен.</td>
  </tr>
  <tr id="responseType">
   <td><code>responseType</code></td>
   <td><code>XMLHttpRequestResponseType</code></td>
   <td>
    <p>Может использоваться для определения типа ответа.</p>

    <table class="standard-table" style="width: auto;">
     <tbody>
      <tr>
       <td class="header">Value</td>
       <td class="header">Data type of <code>response</code> property</td>
      </tr>
      <tr>
       <td><code>""</code> (пустая строка)</td>
       <td>String (строка, дефолтное значение)</td>
      </tr>
      <tr>
       <td><code>"arraybuffer"</code></td>
       <td><a href="/en/JavaScript_typed_arrays/ArrayBuffer" title="en/JavaScript typed arrays/ArrayBuffer"><code>ArrayBuffer</code></a></td>
      </tr>
      <tr>
       <td><code>"blob"</code></td>
       <td>{{ domxref("Blob") }}</td>
      </tr>
      <tr>
       <td><code>"document"</code></td>
       <td>{{ domxref("Document") }}</td>
      </tr>
      <tr>
       <td><code>"json"</code></td>
       <td>JavaScript объект, полученный путём парсинга JSON строки, полученной с сервера.</td>
      </tr>
      <tr>
       <td><code>"text"</code></td>
       <td>String (строка)</td>
      </tr>
      <tr>
       <td><code>"moz-blob"</code></td>
       <td>Firefox - велосипед, который позволяет работать с частично-полученными данными {{ domxref("Blob") }} при помощи событий прогресса (progressing events). Эта штука позволяет работать с ответом от сервера, до того как он получен полностью.</td>
      </tr>
      <tr>
       <td><code>"moz-chunked-text"</code></td>
       <td>
        <p>Похоже на поле <code>"text"</code>, но только находится в потоке(streaming). Это значит, что значение доступно только в промежуток времени между событиями прогресса (<code>"progress"</code> event), и содержит данные которые пришли из последнего события прогресса.</p>

        <p>Поле содержит строку, пока выполняются события прогресса. После того как ответ получен полностью, значение поля меняется на <code>null</code>.</p>

        <p>Работает только в Firefox.</p>
       </td>
      </tr>
      <tr>
       <td><code>"moz-chunked-arraybuffer"</code></td>
       <td>
        <p>Похоже на поле <code>"arraybuffer"</code>, но только находится в потоке(streaming). Это значит, что значение доступно только в промежуток времени между событиями прогресса (<code>"progress"</code> event), и содержит данные которые пришли из последнего события прогресса.</p>

        <p>Поле содержит строку, пока выполняются события прогресса. После того как ответ получен полностью, значение поля меняется на <code>null</code>.</p>

        <p>Работает только в Firefox.</p>
       </td>
      </tr>
     </tbody>
    </table>

    <div class="note"><strong>Note:</strong> Starting with Gecko 11.0 {{ geckoRelease("11.0") }}, as well as WebKit build 528, these browsers no longer let you use the <code>responseType</code> attribute when performing synchronous requests. Attempting to do so throws an <code>NS_ERROR_DOM_INVALID_ACCESS_ERR</code> exception. This change has been proposed to the W3C for standardization.</div>
   </td>
  </tr>
  <tr id="responseXML">
   <td><code>responseXML</code> {{ReadOnlyInline()}}</td>
   <td><code>Document?</code></td>
   <td>
    <p>Ответ является объектом DOM <code><a class="internal" href="/en/DOM/document" title="En/DOM/Document">Document</a></code>, или <code>null в случае если запрос окончился ошибкой, или ответ не получен полностью, или если ответ невозможно распарсить как </code>XML или HTML. Ответ парсится как если бы это был <code>text/xml</code> stream. Когда значение <code>responseType</code> равно <code>"document"</code> и запрос выполнен асинхронно, ответ парсится как <code>text/html</code> stream.</p>

    <div class="note"><strong>Примечание:</strong> Если сервер не работает с заголовком (не присылает в ответе) "Content-type: <code>text/xml"</code>, то можно использовать метод <code>overrideMimeType() для того чтобы парсить получаемый ответ как </code>XML.</div>
   </td>
  </tr>
  <tr id="status">
   <td><code>status</code> {{ReadOnlyInline()}}</td>
   <td><code>unsigned short</code></td>
   <td>Статус ответа на запрос. Равен кодам HTTP (200 - успешно, 404 не найдено, 301 - перенесено навсегда).</td>
  </tr>
  <tr id="statusText">
   <td><code>statusText</code> {{ReadOnlyInline()}}</td>
   <td><code>DOMString</code></td>
   <td>Строка статуса ответа. В отличи от поля <code>status</code>, эта строка включает в себя текст - ("<code>200 OK</code>", например).</td>
  </tr>
  <tr id="timeout">
   <td><code>timeout</code></td>
   <td><code>unsigned long</code></td>
   <td>
    <p>Время в миллисекундах, после которого запрос будет отменён. Значение 0 (по умолчанию) значит что таймаута не будет. Никогда.</p>

    <div class="note"><strong>Примечание:</strong> Вы можете не использовать поле timeout для синхронных запросов из owning window.</div>
   </td>
  </tr>
  <tr id="ontimeout">
   <td><code>ontimeout</code></td>
   <td><code>Function</code></td>
   <td>
    <p>Колбэк-функция которая будет вызвана в случае таймаута.</p>
   </td>
  </tr>
  <tr id="upload">
   <td><code>upload</code></td>
   <td><code>XMLHttpRequestUpload</code></td>
   <td>Загрузка (upload process) может отслеживаться обработчиком события.</td>
  </tr>
  <tr id="withCredentials">
   <td><code>withCredentials</code></td>
   <td><code>boolean</code></td>
   <td>
    <p>Определяет что cross-site запрос, согласно <code>Access-Control</code>  должен использовать авторизацию (креды для логина и пароля) через куки, или заголовок с авторизационными данными. По умолчанию false.</p>

    <div class="note"><strong>Примечание:</strong> Не влияет на same-site запросы.</div>

    <div class="note"><strong>Примечание:</strong> Начиная с Gecko 11.0 {{ geckoRelease("11.0") }}, Gecko больше не позволяет использовать поле <code>withCredentials</code> при выполнении синхронных запросов. Попытка выполнить это выбрасывает <code>NS_ERROR_DOM_INVALID_ACCESS_ERR</code> исключение.</div>
   </td>
  </tr>
 </tbody>
</table>

<h3 id="Нестандартные_свойства">Нестандартные свойства</h3>

<table class="standard-table">
 <tbody>
  <tr>
   <th>Attribute</th>
   <th>Type</th>
   <th>Description</th>
  </tr>
  <tr id="channel">
   <td><code>channel</code> {{ReadOnlyInline()}}</td>
   <td>{{Interface("nsIChannel")}}</td>
   <td>The channel used by the object when performing the request. This is <code>null</code> if the channel hasn't been created yet. In the case of a multi-part request, this is the initial channel, not the different parts in the multi-part request. <strong>Requires elevated privileges to access.</strong></td>
  </tr>
  <tr id="mozAnon">
   <td><code>mozAnon</code> {{ReadOnlyInline()}}</td>
   <td><code>boolean</code></td>
   <td>
    <p>Если значение равно true, запрос отправляется без куки и заголовков авторизации.</p>
   </td>
  </tr>
  <tr id="mozSystem">
   <td><code>mozSystem</code> {{ReadOnlyInline()}}</td>
   <td><code>boolean</code></td>
   <td>
    <p>Если значение равно true, same origin policy не будут использоваться в запросе (кроссдоменный запрос не сработает).</p>
   </td>
  </tr>
  <tr id="mozBackgroundRequest">
   <td><code>mozBackgroundRequest</code></td>
   <td><code>boolean</code></td>
   <td>
    <div class="note">
    <p>Этот метод не может быть вызван из контекста страницы. Для того чтобы воспользоваться им нужны повышенные привелегии (elevated privileges).</p>
    </div>

    <p>Флаг, означающий что запрос от пользователя надо скрыть. Для пользователя не появится никаких сообщений и/или оповещений что запрос вообще был.</p>

    <p>В случае, если для продолжения запроса нужна какая-то аутентификация, и в других случаях было бы отображено оповещение, этот запрос просто не сработает.</p>

    <div class="note"><strong>Note: Этот флаг должен быть выставлен до вызова метода </strong><code>open()</code>.</div>
   </td>
  </tr>
  <tr id="mozResponseArrayBuffer">
   <td><code>mozResponseArrayBuffer</code> {{ obsolete_inline("6") }} {{ReadOnlyInline()}}</td>
   <td><a href="/en/JavaScript_typed_arrays/ArrayBuffer" title="en/JavaScript typed arrays/ArrayBuffer"><code>ArrayBuffer</code></a></td>
   <td>Массив, в который ляжет ответ от сервера, если ответ приходит в виде Javascript массива ([]). В случае, если запрос не удалось завершить, или если запрос не был отправлен, то это поле будет null.</td>
  </tr>
  <tr id="multipart">
   <td><code>multipart</code> {{ obsolete_inline("22") }}</td>
   <td><code>boolean</code></td>
   <td>
    <p><strong>This Gecko-only feature was removed in Firefox/Gecko 22.</strong> Please use <a href="/en-US/docs/Server-sent_events" title="/en-US/docs/Server-sent_events">Server-Sent Events</a>, <a href="/en-US/docs/WebSockets" title="/en-US/docs/WebSockets">Web Sockets</a>, or <code>responseText</code> from progress events instead.</p>

    <p>Indicates whether or not the response is expected to be a stream of possibly multiple XML documents. If set to <code>true</code>, the content type of the initial response must be <code>multipart/x-mixed-replace</code> or an error will occur. All requests must be asynchronous.</p>

    <p>This enables support for server push; for each XML document that's written to this request, a new XML DOM document is created and the <code>onload</code> handler is called between documents.</p>

    <div class="note"><strong>Note:</strong> When this is set, the <code>onload</code> handler and other event handlers are not reset after the first XMLdocument is loaded, and the <code>onload</code> handler is called after each part of the response is received.</div>
   </td>
  </tr>
 </tbody>
</table>

<h2 id="Конструктор">Конструктор</h2>

<h3 id="XMLHttpRequest()">XMLHttpRequest()</h3>

<p>Конструктор создаёт объект XMLHttpRequest. Он должен быть вызван перед обращением к любому методу класса.</p>

<p>Gecko/Firefox 16 добавляет нестандартные параметры в конструктор, для лучшего взаимодействия с режимом инкогнито, (смотри <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=692677" title="692677 – Relax same-origin XHR restrictions for privileged applications">Bug 692677</a>). Установка флага <code>mozAnon</code> в значение <code>true</code> создаёт сущность <a href="http://www.w3.org/TR/2012/WD-XMLHttpRequest-20120117/#dom-anonxmlhttprequest" title="see AnonXMLHttpRequest in the XMLHttpRequest specification"><code>AnonXMLHttpRequest()</code></a> описанную в XMLHttpRequest спецификации, но не реализованную не в одном из браузеров (информация сентября 2012).</p>

<pre>XMLHttpRequest (
  JSObject objParameters
);</pre>

<h5 id="Параметры_(нестандартные)">Параметры (нестандартные)</h5>

<dl>
 <dt><code>objParameters</code></dt>
 <dd>Вы можете использовать два флага:
 <dl>
  <dt><code>mozAnon</code></dt>
  <dd>Boolean: Использование этого флага уберёт из запроса заголовки origin, и <a href="http://www.w3.org/TR/2012/WD-XMLHttpRequest-20120117/#user-credentials" title="Defintion of “User credentials” in the XMLHttpRequest specification.">user credentials</a>. Кроме этого, куки не будут отправлены в запросе, если только они не будут добавлены к запросу специально, через метод setRequestHeader.</dd>
  <dt><code>mozSystem</code></dt>
  <dd>Boolean: Если выставить этот флаг в значение <code>true</code> то это позволит делать cross-доменные запросы без необходимости получения специальных заголовков со стороны сервера (CORS). Для использования этого флага необходимо использовать дополнительный флаг<em> <code>mozAnon: true</code>, поскольку для отправки запроса на другой домен, нельзя использовать куки и креды пользователя. Этот флаг <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=692677#c68" title="Bug 692677 comment 68">работает только с привилегированными (одобренными) приложениями</a>; он не сработает с произвольно загруженными страницами.</em></dd>
 </dl>
 </dd>
</dl>

<h2 id="Методы">Методы</h2>

<h3 id="abort()">abort()</h3>

<p>Отменяет запрос, если он был отправлен.</p>

<h3 id="getAllResponseHeaders()">getAllResponseHeaders()</h3>

<pre>DOMString getAllResponseHeaders();</pre>

<p>Возвращает все заголовки ответа как строку, или <code>null</code> если ответ не был получен. Для multypart запросов возвращает заголовки текущей части запроса, а не всего канала.</p>

<h3 id="getResponseHeader()">getResponseHeader()</h3>

<pre>DOMString? getResponseHeader(DOMString <var>header</var>);</pre>

<p>Возвращает значение указанного заголовка из полученного ответа, или <code>null</code> в случает если ответ не получен, или такого заголовка в ответе нет. Возвращаемая строка имеет кодировку UTF.</p>

<div class="note">
<p><code><strong>Примечание: </strong>Если в ответе есть заголовки с одни названием, то значения этих заголовков будут объеденены в одну строку, разделённую запятой и пробелом.</code></p>
</div>

<h3 id="open()">open()</h3>

<p>Инициализирует запрос. Этот метод может (и должен) быть вызван из JavaScript-кода; если необходимо вызвать запрос из нативного кода, то нужно использовать метод <a class="internal" href="/en/nsIXMLHttpRequest#openRequest()" title="/en/XMLHttpRequest#openRequest()"><code>openRequest()</code></a>.</p>

<div class="note"><strong>Примечание:</strong> Вызов этого метода из активного запроса (если метод <code>open() или</code> <code>openRequest() уже были вызваны</code>) эквивалентно вызову метода <code>abort()</code>.</div>

<pre>void open(
   DOMString <var>method</var>,
   DOMString <var>url</var>,
   optional boolean <var>async</var>,
   optional DOMString <var>user</var>,
   optional DOMString <var>password</var>
);
</pre>

<h6 id="Параметры">Параметры</h6>

<dl>
 <dt><code>method</code></dt>
 <dd>HTTP метод отправки сообщения - "GET", "POST", "PUT", "DELETE", и проч.. Ignored for non-HTTP(S) URLs.</dd>
 <dt><code>url</code></dt>
 <dd>URL адрес, на который будет отправлено сообщение.</dd>
 <dt><code>async</code></dt>
 <dd>Необязательный boolean параметр, по умолчанию равный <code>true. Определяет, будет ли запрос отправлен асинхронно. Если значение равно</code> <code>false</code>, метод <code>send() вернёт ответ в общем потоке работы приложения (иначе говоря, приложение зависнет на некоторое время), в противном случае, ответ может быть получен только при помощи определённых </code> обработчиков событий. В случае, если используется отправка <code>multipart</code> запроса, то этот атрибут <strong>должен </strong>быть <code>true</code>, или будет выброшено исключение.
 <div class="note"><strong>Примечание:</strong> Начиная с Gecko 30.0 {{ geckoRelease("30.0") }}, синхронные запросы объявлены как deprecated, в силу того что все пользователи недовольны тем, что приложение "зависает".</div>
 </dd>
 <dt><code>user</code></dt>
 <dd>Необязательный параметр, используется для аутентификации пользователя. По умолчанию, пустая строка.</dd>
 <dt><code>password</code></dt>
 <dd>Необязательный параметр, используется для аутентификации пользователя. По умолчанию пустая строка.</dd>
</dl>

<h3 id="overrideMimeType()">overrideMimeType()</h3>

<p>Переопределяет MIME тип, получаемый от сервера. Это может быть использовано, например, для того чтобы получить и распарсить данные в формате text/xml, даже, если сервер сообщает что это не так. Этот метод должен быть вызван перед вызовом метода <code>send()</code>.</p>

<pre>void overrideMimeType(DOMString <var>mimetype</var>);</pre>

<h3 id="send()">send()</h3>

<p>Отправляет запрос. Если запрос асинхронный (а по умолчанию это так), этот метод вернёт значение сразу после того как метод вызван.</p>

<div class="note">
<p><strong>Примечание переводчика: </strong>в этом случае, в ответе не будет содержаться информации, которая пришла с сервера, поскольку она ещё не пришла. Для того чтобы получить эту информацию, нужно слушать события загрузки, или использовать promise.</p>
</div>

<p>Если запрос синхронный, то метод вернёт значение только после того, как придёт запрос от сервера.</p>

<div class="note"><strong>Примечание:</strong> все необходимые обработчики событий должны быть установлены перед вызовом <code>send()</code>.</div>

<div class="note"><strong>Примечание:</strong> Лучше не использовать параметр ArrayBuffer. Сейчас он не входит в спецификацию <code>XMLHttpRequest</code>. Вместо него можно использовать ArrayBufferView (смотри таблицу совместимости для различных версий).</div>

<pre>void send();
<s>void send(ArrayBuffer <var>data</var>);</s>
void send(ArrayBufferView <var>data</var>);
void send(Blob <var>data</var>);
void send(Document <var>data</var>);
void send(DOMString? <var>data</var>);
void send(FormData <var>data</var>);</pre>

<h6 id="Примечания">Примечания</h6>

<p>Если тип <var>data</var> - <code>Document</code>, то он будет сериализован перед отправкой. Firefox до версии 3 всегда отправляет такой запрос в кодировке UTF-8; <a href="/en/Firefox_3" rel="internal" title="en/Firefox_3">Firefox 3</a> отправляет данные в той кодировке, которая указаны в <code>body.xmlEncoding</code>, или UTF-8 если такой информации нет.</p>

<p>If it's an <code>nsIInputStream</code>, it must be compatible with <code>nsIUploadChannel</code>'s <code>setUploadStream()</code>method. In that case, a Content-Length header is added to the request, with its value obtained using <code>nsIInputStream</code>'s <code>available()</code>method. Any headers included at the top of the stream are treated as part of the message body. The stream's MIMEtype should be specified by setting the Content-Type header using the <a class="internal" href="#setRequestHeader()" title="/en/XMLHttpRequest#setRequestHeader()"><code>setRequestHeader()</code></a> method prior to calling <code>send()</code>.</p>

<p>The best way to send binary content (like in files upload) is using an <a href="/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView" title="/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView">ArrayBufferView</a> or <a href="/en-US/docs/DOM/Blob" title="/en-US/docs/DOM/Blob">Blobs</a> in conjuncton with the <code>send()</code> method. However, if you want to send a <a href="/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify" title="/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify">stringifiable</a> raw data, use the <a href="/en-US/docs/DOM/XMLHttpRequest#sendAsBinary()" title="/en-US/docs/DOM/XMLHttpRequest#sendAsBinary()"><code>sendAsBinary()</code></a> method instead, or the <a href="/en-US/docs/Web/JavaScript/Typed_arrays/StringView" title="/en-US/docs/Web/JavaScript/Typed_arrays/StringView"><code>StringView</code></a> <span class="inlineIndicator" title="This API is not native.">Non native</span> typed arrays superclass.</p>

<h3 id="setRequestHeader()">setRequestHeader()</h3>

<p>Устанавливает значение заголовка HTTP-запроса. Вы должны вызвать <code>setRequestHeader()</code> после <a href="#open"><code>open()</code></a>, но перед <code>send()</code>. Если данный метод вызывается несколько раз с одним и тем же заголовком, все значения объединяются в один заголовок запроса.</p>

<pre>void setRequestHeader(
   DOMString <var>header</var>,
   DOMString <var>value</var>
);
</pre>

<h6 id="Параметры_2">Параметры</h6>

<dl>
 <dt><code>header</code></dt>
 <dd>Имя заголовка, значение которого будет установлено.</dd>
 <dt><code>value</code></dt>
 <dd>Значение, заданное как тело заголовка.</dd>
</dl>

<h3 id="Нестандартные_методы">Нестандартные методы</h3>

<h4 id="init()">init()</h4>

<p>Инициализирует объект для использования с C++ кодом.</p>

<div class="warning"><strong>Внимание:</strong> Этот метод <strong><em>нельзя</em></strong> вызывать из JavaScript.</div>

<pre>[noscript] void init(
   in nsIPrincipal principal,
   in nsIScriptContext scriptContext,
   in nsPIDOMWindow ownerWindow
);
</pre>

<h5 id="Параметры_3">Параметры</h5>

<dl>
 <dt><code>principal</code></dt>
 <dd>
 <p>Принцип, используемый для запроса; не должен быть <code>null</code>.</p>
 </dd>
 <dt><code>scriptContext</code></dt>
 <dd>
 <p>Контекст скрипта, используемого для запроса; не должен быть <code>null</code>.</p>
 </dd>
 <dt><code>ownerWindow</code></dt>
 <dd>
 <p>Окно, связанное с запросом; может быть <code>null</code>.</p>
 </dd>
</dl>

<h4 id="openRequest()">openRequest()</h4>

<p>Инициализирует запрос. Этот метод должен использоваться из собственного кода; для инициализации запроса из кода JavaScript вместо этого используйте используйте <code><a class="internal" href="/en/nsIXMLHttpRequest#open()" title="/en/XMLHttpRequest#open()">open()</a></code> метод. Смотрите документацию для <code><a class="internal" href="/en/nsIXMLHttpRequest#open()" title="/en/XMLHttpRequest#open()">open()</a></code>.</p>

<h4 id="sendAsBinary()_deprecated_inline(31)">sendAsBinary() {{ deprecated_inline(31) }}</h4>

<p>Вариант метода <code>send()</code> который посылает бинарные данные.</p>

<div class="note"><strong>Примечание:</strong> Этот нестандартный метод считается устарелым по состоянию на Gecko 31 {{ geckoRelease(31) }}, и со временем будет удалён. Взамен может использоваться стандарт метода <code>send(Blob data).</code> </div>

<pre>void sendAsBinary(
   in DOMString body
);
</pre>

<p>Данный метод используется в сочетании с методом <code><a href="/en-US/docs/DOM/FileReader#readAsBinaryString()" title="/en-US/docs/DOM/FileReader#readAsBinaryString()">readAsBinaryString</a>,</code> который присутствует в <a href="/en-US/docs/DOM/FileReader" title="/en-US/docs/DOM/FileReader"><code>FileReader</code></a> API, и позволяет <a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files" title="/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files">прочитать и <strong>загрузить</strong> файл любого типа</a> и превратить необработанные данные в <a href="/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify" title="/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify">JSON-строку</a>.</p>

<h5 id="Параметры_4">Параметры</h5>

<dl>
 <dt><code>body</code></dt>
 <dd>Тело запроса в виде <a href="https://developer.mozilla.org/ru/docs/Web/API/DOMString">DOMstring</a>. Эти данные конвертированы в строку с однобайтовыми символами с помощью усечения (удаления байта с высоким порядком в каждом символе).</dd>
</dl>

<h5 id="sendAsBinary()_polyfill"><code>sendAsBinary()</code> polyfill</h5>

<p>Since <code>sendAsBinary()</code> is an experimental feature, here is <strong>a polyfill</strong> for browsers that <em>don't</em> support the <code>sendAsBinary()</code> method but support <a href="/en-US/docs/JavaScript/Typed_arrays" title="/en-US/docs/JavaScript/Typed_arrays">typed arrays</a>.</p>

<pre class="brush: js">/*\
|*|
|*|  :: XMLHttpRequest.prototype.sendAsBinary() Polyfill ::
|*|
|*|  https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#sendAsBinary()
|*|
\*/

if (!XMLHttpRequest.prototype.sendAsBinary) {
  XMLHttpRequest.prototype.sendAsBinary = function (sData) {
    var nBytes = sData.length, ui8Data = new Uint8Array(nBytes);
    for (var nIdx = 0; nIdx &lt; nBytes; nIdx++) {
      ui8Data[nIdx] = sData.charCodeAt(nIdx) &amp; 0xff;
    }
    /* send as ArrayBufferView...: */
    this.send(ui8Data);
    /* ...or as ArrayBuffer (legacy)...: this.send(ui8Data.buffer); */
  };
}</pre>

<div class="note"><strong>Note:</strong> It's possible to build this polyfill putting two types of data as argument for <code>send()</code>: an <a href="/en-US/docs/JavaScript/Typed_arrays/ArrayBuffer" title="/en-US/docs/JavaScript/Typed_arrays/ArrayBuffer"><code>ArrayBuffer</code></a> (<code>ui8Data.buffer</code> – the commented code) or an <a href="/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView" title="/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a> (<code>ui8Data</code>, which is a <a href="/en-US/docs/JavaScript/Typed_arrays/Uint8Array" title="/en-US/docs/JavaScript/Typed_arrays/Uint8Array">typed array of 8-bit unsigned integers</a> – uncommented code). However, on Google Chrome, when you try to send an <code>ArrayBuffer</code>, the following warning message will appear: <code>ArrayBuffer is deprecated in XMLHttpRequest.send(). Use ArrayBufferView instead.</code> Another possible approach to send binary data is the <a href="/en-US/docs/Web/JavaScript/Typed_arrays/StringView" title="/en-US/docs/Web/JavaScript/Typed_arrays/StringView"><code>StringView</code></a> <span class="inlineIndicator" style="background-color: #ffffff;" title="This API is not native.">Non native</span> typed arrays superclass in conjunction with the <a href="#send()" title="#send()"><code>send()</code></a> method.</div>

<h2 id="Notes">Notes</h2>

<ul>
 <li class="note">By default, Firefox 3 limits the number of <code>XMLHttpRequest</code> connections per server to 6 (previous versions limit this to 2 per server). Some interactive web sites may keep an <code>XMLHttpRequest</code> connection open, so opening multiple sessions to such sites may result in the browser hanging in such a way that the window no longer repaints and controls don't respond. This value can be changed by editing the <code>network.http.max-persistent-connections-per-server</code> preference in <code><a class="linkification-ext" href="/about:config" title="Linkification: about:config">about:config</a></code>.</li>
 <li class="note">From {{ gecko("7.0") }} headers set by {{ manch("setRequestHeader") }} are sent with the request when following a redirect. Previously these headers would not be sent.</li>
 <li class="note"><code>XMLHttpRequest</code> is implemented in Gecko using the {{ interface("nsIXMLHttpRequest") }}, {{ interface("nsIXMLHttpRequestEventTarget") }}, and {{ interface("nsIJSXMLHttpRequest") }} interfaces.</li>
 <li class="note">When a request reaches its timeout value, a "timeout" event is raised.</li>
</ul>

<h4 class="note" id="Events">Events</h4>

<p><code>onreadystatechange</code> as a property of the <code>XMLHttpRequest</code> instance is supported in all browsers.</p>

<p>Since then, a number of additional event handlers were implemented in various browsers (<code>onload</code>, <code>onerror</code>, <code>onprogress</code>, etc.). These are supported in Firefox. In particular, see {{ interface("nsIXMLHttpRequestEventTarget") }} and <a href="/en/DOM/XMLHttpRequest/Using_XMLHttpRequest" title="En/XMLHttpRequest/Using_XMLHttpRequest">Using XMLHttpRequest</a>.</p>

<p>More recent browsers, including Firefox, also support listening to the <code>XMLHttpRequest</code> events via standard <code><a href="/en/DOM/element.addEventListener" title="element.addEventListener">addEventListener</a></code> APIs in addition to setting <code>on*</code> properties to a handler function.</p>

<h2 id="Permissions">Permissions</h2>

<p>When using System XHR via the <code>mozSystem</code> property, for example for Firefox OS apps, you need to be sure to add the <code>systemXHR</code> permission into your manifest file. System XHR can be used in privileged or certified apps.</p>

<pre class="brush: js">"permissions": {
    "systemXHR":{}
}</pre>

<h2 id="Browser_Compatibility">Совместимость с браузерами</h2>

<p>{{Compat}}</p>

<h2 id="See_also">See also</h2>

<ul>
 <li>MDN articles about XMLHttpRequest:
  <ul>
   <li><a href="/en/AJAX/Getting_Started" title="en/AJAX/Getting_Started">AJAX - Getting Started</a></li>
   <li><a href="/en/DOM/XMLHttpRequest/Using_XMLHttpRequest" title="En/Using XMLHttpRequest">Using XMLHttpRequest</a></li>
   <li><a href="/en/HTML_in_XMLHttpRequest" title="en/HTML_in_XMLHttpRequest">HTML in XMLHttpRequest</a></li>
   <li><a href="/en/DOM/XMLHttpRequest/FormData" title="en/XMLHttpRequest/FormData"><code>FormData</code></a></li>
  </ul>
 </li>
 <li>XMLHttpRequest references from W3C and browser vendors:
  <ul>
   <li><a class="external" href="http://www.w3.org/TR/XMLHttpRequest1/">W3C: XMLHttpRequest</a> (base features)</li>
   <li><a class="external" href="http://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html">W3C: XMLHttpRequest</a> (latest editor's draft with extensions to the base functionality, formerly XMLHttpRequest Level 2</li>
   <li><a class="external" href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/xmlsdk/html/xmobjxmlhttprequest.asp">Microsoft documentation</a></li>
   <li><a class="external" href="https://developer.apple.com/library/safari/#documentation/AppleApplications/Conceptual/SafariJSProgTopics/Articles/XHR.html">Apple developers' reference</a></li>
  </ul>
 </li>
 <li><a class="external" href="http://jibbering.com/2002/4/httprequest.html">"Using the XMLHttpRequest Object" (jibbering.com)</a></li>
 <li><a class="external" href="http://www.peej.co.uk/articles/rich-user-experience.html">XMLHttpRequest - REST and the Rich User Experience</a></li>
 <li><a class="external" href="http://www.html5rocks.com/en/tutorials/file/xhr2/">HTML5 Rocks - New Tricks in XMLHttpRequest2</a></li>
 <li><a href="http://programmers.stackexchange.com/questions/157375/why-does-xmlhttprequest-not-seem-to-follow-a-naming-convention">Thread on the naming convention of <code>XMLHttpRequest</code></a></li>
 <li><code>Chrome scope availability</code> - how to access from JSM modules etc which do not have access to DOM
  <ul>
   <li><a href="/en-US/docs/Components.utils.importGlobalProperties">Components.utils.importGlobalProperties</a></li>
   <li><a href="/en-US/docs/nsIXMLHttpRequest">nsIXMLHttpRequest [en-US]</a></li>
  </ul>
 </li>
</ul>
