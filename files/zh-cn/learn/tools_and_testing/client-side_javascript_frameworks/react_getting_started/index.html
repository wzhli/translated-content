---
title: React 入门
slug: >-
  Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started
tags:
  - JavaScript
  - React
  - 初学者
  - 学习
  - 客户端
  - 框架
translation_of: >-
  Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started
---
<div>{{LearnSidebar}}</div>

<div>{{PreviousMenuNext("Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Main_features","Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_todo_list_beginning", "Learn/Tools_and_testing/Client-side_JavaScript_frameworks")}}</div>

<p class="summary"><font><font>本文会引导我们进入一段 React 学习之旅。</font><font>我们将逐步了解有关它的背景和用例的一些细节，在自己的电脑上建起基本的 React 工具链，创建并使用一个简单的入门应用程序，以学习一些关于 React 在此过程中如何工作的知识。</font></font></p>

<table class="learn-box standard-table">
 <tbody>
  <tr>
   <th scope="row"><font><font>先决条件：</font></font></th>
   <td>
    <p><font><font>熟悉核心 </font></font><a href="/en-US/docs/Learn/HTML"><font><font>HTML</font></font></a><font><font>，</font></font><font><font><a href="/en-US/docs/Learn/CSS">CSS</a> </font></font><font><font>和 </font></font><font><font><a href="/en-US/docs/Learn/JavaScript">JavaScript</a> </font></font><font><font>语言，了解</font></font><a href="/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Command_line"><font><font>终端/命令行</font></font></a><font><font>。</font></font></p>

    <p><font><font>React 使用称为 JSX（JavaScript 和 XML）的 HTML-in-JavaScript 语法。</font><font>熟悉 HTML 和 JavaScript 可以帮助您学习 JSX，并更好地确定应用程序中的错误是与 JavaScript 还是与 React 的更特定领域相关。</font></font></p>
   </td>
  </tr>
  <tr>
   <th scope="row"><font><font>目的：</font></font></th>
   <td><font><font>要设置本地 React 开发环境，创建一个启动应用程序，并了解其工作原理</font></font></td>
  </tr>
 </tbody>
</table>

<h2 id="你好_React"><font><font>你好 React</font></font></h2>

<p><font><font>如其官方口号所示，</font></font><font><font><a href="https://reactjs.org/">React</a> 是一个用于构建用户界面的库。React 不是一个框架 —— 它的应用甚至不局限于 Web 开发，它可以与其他库一起使用以渲染到特定环境。例如，</font></font><font><font><a href="https://reactnative.dev/">React Native</a> </font></font><font><font>可用于构建移动应用程序；</font></font><font><font><a href="https://facebook.github.io/react-360/">React 360</a> </font></font><font><font>可用于构建虚拟现实应用程序……</font></font></p>

<p><font><font>为了构建 Web 应用，开发人员将 React 与 </font></font><a href="https://reactjs.org/docs/react-dom.html"><font><font>ReactDOM 结合使用</font></font></a><font><font>。</font><font>React 和 ReactDOM 通常被与其他真正的 Web 开发框架相提并论，并用于解决相同的问题。</font><font>当我们将 React 称为“框架”时，</font></font>就是在进行口语化的理解<font><font>。</font></font></p>

<p><font><font>React 的主要目标是最大程度地减少开发人员构建 UI 时发生的错误。它通过使用组件——描述部分用户界面的、自包含的逻辑代码段——来实现此目的。这些组件可以组合在一起以创建完整的 UI，React 将许多渲染工作进行抽象化，使您可以专注于 UI 设计(译者注：显而易见，此设计不等于视觉稿的设计)。</font></font></p>

<h2 id="用例"><font><font>用例</font></font></h2>

<p><font><font>与本模块中涵盖的其他框架不同，React 不会对代码约定或文件组织实施严格的规则。</font><font>这使团队可以设置最适合自己的约定，并以他们希望的任何方式采用 React。</font><font>React 可以处理一个按钮，一个界面的几个部分或应用程序的整个用户界面。</font></font></p>

<div style="padding-top: 5px;">
<p><span>尽管 React 可以用于<a href="https://reactjs.org/docs/add-react-to-a-website.html">界面的小片段</a>中，但要和 jQuery 这样的库，甚至是像 Vue 这样的框架那样“引入”应用程序并不容易 —— 当你使用 React 构建整个应用程序时更容易上手</span><span>。</span></p>
</div>

<p>另外，许多开发人员的经验对于 React 应用程序也是有用处的，例如使用 JSX 编写界面是需要编译过程的。在网站上添加类似于 Babel 的编译器会让网站上代码的运行速度变慢，因此开发人员通常会在构建项目的时候设置这样的工具。React 对于工具的要求可以说是很高的，但这是能够学习解决的。</p>

<p>本文将重点介绍使用 React 通过 Facebook 的 <a href="https://create-react-app.dev/">create-react-app</a> 内的工具渲染应用程序中整个用户界面的用例。</p>

<h2 id="React_如何使用_JavaScript">React 如何使用 JavaScript?</h2>

<p>React 中的许多模式都使用了现代 JavaScript 的功能。React 与 JavaScript 的最大区别在于 <a href="https://reactjs.org/docs/introducing-jsx.html">JSX</a> 语法的使用上。JSX 是在 JavaScript 语法上的拓展，因此类似于 HTML 的代码可以和 JSX 共存。例如：</p>

<pre class="brush: js notranslate">const heading = &lt;h1&gt;Mozilla Developer Network&lt;/h1&gt;;</pre>

<p>该 heading 常量称为 <strong>JSX 表达式</strong>。React 可以使用它在我们的应用程序中渲染 <code><a href="/en-US/docs/Web/HTML/Element/Heading_Elements">&lt;h1&gt;</a></code> 标签。</p>

<p>假设出于语义原因，我们想将 heading 包装 <code><a href="/en-US/docs/Web/HTML/Element/header">&lt;header&gt;</a></code> 在标记中？JSX 方法允许我们将元素彼此嵌套，就像使用 HTML 一样：</p>

<pre class="brush: js notranslate">const header = (
  &lt;header&gt;
    &lt;h1&gt;Mozilla Developer Network&lt;/h1&gt;
  &lt;/header&gt;
);</pre>

<div class="blockIndicator note">
<p><strong>注意</strong>：上一个代码段中的括号并非 JSX 的一部分，它对您的应用程序没有任何影响，括号只是用来向您（和您的计算机）表明其中的多行代码属于同一个表达式(译者注：原文表述实在有点啰嗦)。因此上面的代码等同于：</p>

<pre class="brush: js notranslate">const header = &lt;header&gt;
    &lt;h1&gt;Mozilla Developer Network&lt;/h1&gt;
&lt;/header&gt;</pre>

<p>这看起来多少有点不适感，因为表达式前面的 <code><a href="/en-US/docs/Web/HTML/Element/header">&lt;header&gt;</a></code> 标记没有缩进与其对应的结束标记相同的位置。</p>
</div>

<p>浏览器是无法读取直接解析 JSX 的。我们的 header 表达式经过（ <a href="https://babeljs.io/">Babel</a> 或 <a href="https://parceljs.org/">Parcel</a> 之类的工具）编译之后是这样的：</p>

<pre class="brush: js notranslate">const header = React.createElement("header", null,
  React.createElement("h1", null, "Mozilla Developer Network")
);</pre>

<p><em>可以</em>跳过编译步骤，并使用 <code><a href="https://reactjs.org/docs/react-api.html#createelement">React.createElement()</a></code> 自己编写 UI。但是，这样做会失去 JSX 的声明性优势，并且代码变得更难以阅读。编译是开发过程中的一个额外步骤，但是 React 社区中的许多开发人员都认为 JSX 的可读性值得。另外，流行的工具使 JSX-to-JavaScript 编译成为其设置过程的一部分。除非您愿意，否则不必自己配置编译。</p>

<p>由于 JSX 是 HTML 和 JavaScript 的结合，因此一些开发人员认为它很直观。其他人则说它的混合特性使它变得混乱。但是，一旦熟悉了它，它将使您能够更快，更直观地构建用户界面，并使其他人一眼就能更好地理解您的代码库。</p>

<p>要阅读有关 JSX 的更多信息，请查看 React 团队的 <a href="https://reactjs.org/docs/jsx-in-depth.html">JSX In Depth</a> 文章。</p>

<h2 id="设置您的第一个_React_应用">设置您的第一个 React 应用</h2>

<p>有很多使用 React 的方法，但是我们将使用命令行界面（CLI）工具 create-react-app，如前所述，该方法通过安装一些软件包并创建一些软件包来加快开发 React 应用程序的过程。文件供您处理上述工具。</p>

<p>通过将一些 <code><a href="/en-US/docs/Web/HTML/Element/script">&lt;script&gt;</a></code> 元素复制到 HTML 文件中，可以在<a href="https://reactjs.org/docs/add-react-to-a-website.html">没有 create-react-app 的情况下将 React 添加到网站</a>，但是 create-react-app CLI 是 React 应用程序的常见起点。使用它可以让您花费更多的时间来构建应用，而花更少的时间进行设置。</p>

<h3 id="要求">要求</h3>

<p>为了使用 create-react-app，您需要安装 <a href="https://nodejs.org/en/">Node.js</a>。建议您使用长期支持（LTS）版本。Node 包括 npm（Node 程序包管理器）和 npx（Node 程序包运行器）</p>

<p>您也可以使用 Yarn 软件包管理器作为替代方案，但是我们假设在这套教程中使用 npm。有关 npm 和 yarn 的更多信息，请参见<a href="/zh-CN/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Package_management">程序包管理基础</a>。</p>

<p>如果您使用的是 Windows，则需要安装一些软件以与 Unix/macOS 终端保持同等地位，才能使用本教程中提到的终端命令。<strong>Gitbash</strong>（作为 <a href="https://gitforwindows.org/">git Windows 工具集</a>的一部分提供）或<strong><a href="https://docs.microsoft.com/en-us/windows/wsl/about">适用于 Linux 的 Windows 子系统</a></strong>（<strong>WSL</strong>）均适用。有关这些以及一般终端命令的更多信息，请参见<a href="/zh-CN/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Command_line">命令行速成课程</a>。</p>

<p>还请记住，React 和 ReactDOM 生成的应用程序只能在相当现代的一组浏览器上运行 —— 通过某些 polyfill 可以使用 IE9+。在阅读这些教程时，建议您使用 Firefox，Safari 或 Chrome 等现代浏览器。</p>

<p>另外，有关更多信息，请参见以下内容：</p>

<ul>
 <li><a href="https://nodejs.org/en/knowledge/getting-started/npm/what-is-npm/">"What is npm" on nodejs.org</a></li>
 <li><a href="https://blog.npmjs.org/post/162869356040/introducing-npx-an-npm-package-runner">"Introducing npx" on the npm blog</a></li>
 <li><a href="https://create-react-app.dev/">The create-react-app documentation</a></li>
</ul>

<h3 id="初始化您的应用">初始化您的应用</h3>

<p><code>create-react-app</code> ，该命令接受一个参数：即你想给自己的应用所起的名字。<code>create-react-app</code> 将为此应用创建一个同名的文件夹，并在其中创建所需文件。在你打算放置你的应用程序的文件夹下打开你的命令终端，并键入命令：</p>

<pre class="brush: bash notranslate">npx create-react-app moz-todo-react</pre>

<p>这句命令创建了一个名为 <code>moz-todo-react</code> 的文件夹， 并在此文件夹里做了如下工作：</p>

<ul>
 <li>为你的应用程序安装了一些 npm 包；</li>
 <li>写入 react 应用启动所需要的脚本文件；</li>
 <li>创建一系列结构化的子文件夹和文件，奠定应用程序的基础架构；</li>
 <li>如果你的电脑上安装了 git 的话，顺便帮你把 git 仓库也建好。</li>
</ul>

<div class="blockIndicator note">
<p><strong>注意：如果你的电脑上安装了 yarn 的话， create-react-app 会默认使用 yarn 而非 npm。如果你同时安装了 yarn 和 npm ，但你希望使用 npm 的话，在 create-react-app 的时候需要输入 </strong> <code>--use-npm</code><strong> :</strong></p>

<pre class="brush: bash notranslate">npx create-react-app moz-todo-react --use-npm</pre>
</div>

<p><code>create-react-app</code> 运行的时候会在终端上显示一些与其状态相关的信息，通常情况下无需为此担心。运行需要一点时间，在此期间你可以适度放松一下。</p>

<p>处理完成之后，你可以 <code>cd</code> 到 <code>moz-todo-react</code> 文件夹下，然后键入 <code>npm start</code> 命令并回车，先前由 create-react-app 创建的脚本会启动一个地服务 <a href="localhost:3000">localhost:3000</a>，并打开你的默认浏览器来访问这个服务。成功启动浏览器的话，你的浏览器上会显示如下画面：</p>

<p><img alt="Firefox MacOS的屏幕截图，打开到localhost：3000，显示了默认的create-react-app应用程序" src="https://mdn.mozillademos.org/files/17203/default-create-react-app.png" style="border-style: solid; border-width: 1px; height: 980px; width: 1600px;"></p>

<h3 id="应用结构">应用结构</h3>

<p>create-react-app 提供了开发React应用所需的工具。它的初始文件结构如下：</p>

<pre class="notranslate">moz-todo-react
├── README.md
├── node_modules
├── package.json
├── package-lock.json
├── .gitignore
├── public
│   ├── favicon.ico
│   ├── index.html
│   └── manifest.json
└── src
    ├── App.css
    ├── App.js
    ├── App.test.js
    ├── index.css
    ├── index.js
    ├── logo.svg
    └── serviceWorker.js</pre>

<p>目录 <strong><code>src</code></strong> 是我们花费时间最多的地方，因为它是我们React应用源码存放的目录。</p>

<p>目录 <strong><code>public</code></strong> 包含了开发应用时浏览器会读取的文件，其中最重要的就是 <code>index.html</code>。React将目录 <strong><code>src</code></strong> 中的代码嵌入这个文件，从而浏览器才能运行此文件。 <code>index.html</code>中的有些内容关乎create-react-app的运作，因此除非你知道自己在做什么样的修改，否则不建议编辑这个文件。当然，你可以修改<code>index.html</code>中的 <code><a href="/en-US/docs/Web/HTML/Element/title">&lt;title&gt;</a></code> 元素的内容来表现此应用程序通俗易懂的名称。</p>

<p>目录 <code>public</code> 会在建立并部署此应用的时候更新。此教程不涉及部署，你可以参考 <a href="/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Deployment">Deploying our app</a> 这一篇教程。</p>

<p>文件 <code>package.json</code> 包含了Node.js/npm为了建立该应用程序所管理着的文件信息。这个文件不是React应用独有的。你无需理解这个文件也能看懂这篇教程。 不过，如果你想了解更多，你可以阅读 <a href="https://nodejs.org/en/knowledge/getting-started/npm/what-is-the-file-package-json/">What is the file `package.json`? on NodeJS.org</a> 和 <a href="/en-US/docs/Learn/Tools_and_testing/Understanding_client-side_tools/Package_management">Package management basics</a>。</p>

<h2 id="探索第一个_React_组件_—_&lt;App>">探索第一个 React 组件 — <code>&lt;App/&gt;</code></h2>

<p>在React中，组件是组成应用程序的可重复利用的模块。组件可大可小，但它们都只有单一的、明确的功能。</p>

<p>打开 <code>src/App.js</code>，之前打开的页面也提示我们对这个文件进行编辑。这个文件包含了我们第一个组件 <code>App</code>，内容如下：</p>

<pre class="brush: js notranslate">import React from 'react';
import logo from './logo.svg';
import './App.css';

function App() {
  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;img src={logo} className="App-logo" alt="logo" /&gt;
        &lt;p&gt;
          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.
        &lt;/p&gt;
        &lt;a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        &gt;
          Learn React
        &lt;/a&gt;
      &lt;/header&gt;
    &lt;/div&gt;
  );
}
export default App;</pre>

<p>文件 <code>App.js</code> 主要由三部分组成： 顶部的 <code><a href="/en-US/docs/Web/JavaScript/Reference/Statements/import">import</a></code> 语句， 中间的 <code>App</code> 组件，以及底部的 <code><a href="/en-US/docs/Web/JavaScript/Reference/Statements/export">export</a></code> 语句。大多数React组件都遵循这个模式。</p>

<h3 id="import_语句">import 语句</h3>

<p>脚本开头的 <code>import</code> 语句允许在此脚本中使用其他文件中的代码，让我们更进一步地了解这些语句。</p>

<pre class="brush: js notranslate">import React from 'react';
import logo from './logo.svg';
import './App.css';</pre>

<p>第一句代码引入了 React 库，这是为了将代码中的 JSX 语句转为<code>React.createElement()</code>，所有的 React 模块都应该引入 React 模块，否则会抛错。</p>

<p>第二句代码引入了 <code>'./logo.svg'</code>。注意文件路径以 <code>./</code> 开头、由 <code>.svg</code> 尾——表明这是一个本地文件，并且它不是 JavaScript 文件。</p>

<div class="blockIndicator note">
<p>我们没有指定 React 模块的路径——表明它并非来自本地文件，而是在 <code>package.json</code> 文件中列为依赖项。在整个学习过程中，请务必留心这两种引入方式的不同之处。</p>
</div>

<p>第三行引入了我们的组件所需的 CSS 文件。与上面两句不同，这里没有将引入的内容赋给任何变量、也没有用到 <code>from</code> 指令。请注意这种特殊的语法并非原生 JS 的语法 —— 它源自前端资源打包工具 webpack，而 create-react-app 正是基于 webpack 配置而来的。</p>

<div class="blockIndicator note">
<p>译者补充：webpack 可用于打包 JS 和非 JS 的内容(当然，非 JS 的内容需要一些插件或加载器来处理)，但是 JavaScript 标准只有关于 JS 的内容，所以 webpack 社区使用这种特殊的 `import` 语句来声明对非 JS 内容的引用。</p>

<p>详情参见 webpack 官方和社区，截止目前(2020年下旬)，webpack 仍是现代前端工作中必不可少的技能之一。</p>
</div>

<h3 id="App_组件"><code>App</code> 组件</h3>

<p>在 import 所需资源之后，我们定义了一个名为 App 的函数，尽管大部分 JavaScript 社区推崇使用驼峰式命名法，如：“helloWorld”。但 React 组件使用帕斯卡命名法，如 “HelloWorld”，来帮助用户辨认一个 JSX 元素是 React 组件而非普通的 HTML 标签。如果您将函数名 “App” 改为 “app”，您的浏览器会显示错误。</p>

<p>让我们进一步看下App方法。</p>

<pre class="brush: js notranslate">function App() {
  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;img src={logo} className="App-logo" alt="logo" /&gt;
        &lt;p&gt;
          Edit &lt;code&gt;src/App.js&lt;/code&gt; and save to reload.
        &lt;/p&gt;
        &lt;a
          className="App-link"
          href="https://reactjs.org"
          target="_blank"
          rel="noopener noreferrer"
        &gt;
          Learn React
        &lt;/a&gt;
      &lt;/header&gt;
    &lt;/div&gt;
  );
}</pre>

<p>App方法返回一个JSX表达式，这个表达式定义了浏览器最终要渲染的DOM。</p>

<p>表达式中的元素就像以前写的HTML一样，都拥有属性，并且遵循 <code>attribute="value"</code> 的模式。 在第三行，开始标签 <code><a href="/en-US/docs/Web/HTML/Element/div">&lt;div&gt;</a></code> 有着 <code>className</code> 属性。 这个属性与在HTML中的 <code><a href="/en-US/docs/Web/HTML/Global_attributes/class">class</a></code> 属性相同，但是由于JSX就是JavaScript, 我们不能使用 <code>class</code> 属性 - 这个是关键字，意味着JavaScript已经用它执行其它任务，使用 <code>class</code> 属性将会在我们的代码中产生冲突。由于同样的原因，一些其它的HTML属性在JSX中也有着不同的书写方式，当我们碰到它们时，我们将会详述。</p>

<p>把第6行的 <code><a href="/en-US/docs/Web/HTML/Element/p">&lt;p&gt;</a></code> 标签内容改为 "Hello, world!" 并保存文件。你会发现这个改变也会立即在浏览器的<code>http://localhost:3000</code> 中同步渲染。 现在删掉 <code><a href="/en-US/docs/Web/HTML/Element/a">&lt;a&gt;</a></code> 标签并保存，"Learn React"链接也会同样被删除。</p>

<p>你的 <code>App</code> 组件应该如下所示:</p>

<pre class="brush: js notranslate">function App() {
  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;img src={logo} className="App-logo" alt="logo" /&gt;
        &lt;p&gt;
          Hello, World!
        &lt;/p&gt;
      &lt;/header&gt;
    &lt;/div&gt;
  );
}</pre>

<h3 id="Export_statements">Export 语句</h3>

<p>在 <code>App.js</code> 文件的最底部,  <code>export default App</code> 语句使得 <code>App</code> 组件能被其它模块使用.</p>

<h2 id="Interrogating_the_index">Interrogating the index</h2>

<p>现在让我们打开 <code>src/index.js</code>, 因为这也是 <code>App</code> 组件被用到的地方。 这个文件是我们 app 的入口点，在一开始它如下所示</p>

<pre class="brush: js notranslate">import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';
import * as serviceWorker from './serviceWorker';

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));

// If you want your app to work offline and load faster, you can change
// unregister() to register() below. Note this comes with some pitfalls.
// Learn more about service workers: https://bit.ly/CRA-PWA
serviceWorker.unregister();</pre>

<p>就像 <code>App.js</code> 一样,这个文件一开始 import 了所有的 JS 模块和其它运行所需要的资源。<code>src/index.css</code>定义了运用于整个 app 的 global style。 我们可以看到我们的 <code>App</code> 组件也被 imported 了， 这是在 <code>App.js</code> 底部的语句让 import <code>App</code> 变得可行。</p>

<p>第七行调用 React 的 <code>ReactDOM.render()</code> 函数，并传入两个参数：</p>

<ul>
 <li>我们想要渲染的组件, 在这个例子中是 <code>&lt;App /&gt;</code> .</li>

 <li>我们想要渲染组件所在的 DOM 元素，在这个例子中是带着 <code>root</code> 标签的元素。 让我们看一下 <code>public/index.html</code> 的代码， 可以看到这有一个 <code>&lt;div&gt;</code> 元素 在 <code>&lt;body&gt;</code> 里。 </li>
</ul>

<p>上述所有都告诉 React 我们想把 <code>App</code> 组件作为 root 或者第一个组件来渲染我们的 React App。</p>

<div class="blockIndicator note">
<p><strong>注意</strong>: 在 JSX 中， React 组件和 HTML 元素必须有 closing slashes，如 <code>&lt;App /&gt;</code>， 如果我们写 <code>&lt;App&gt;</code> 或者 <code>&lt;img&gt;</code> 将会报错。</p>
</div>

<p><a href="/en-US/docs/Web/API/Service_Worker_API/Using_Service_Workers">Service workers</a> 能让我们的 App 离线运行，但它不在本篇文章的范围中，您可以删除第5行和第9到12行。</p>

<p>您最终的 <code>index.js</code> 文件应该如下所示：</p>

<pre class="brush: js notranslate">import React from 'react';
import ReactDOM from 'react-dom';
import './index.css';
import App from './App';

ReactDOM.render(&lt;App /&gt;, document.getElementById('root'));</pre>

<h2 id="Variables_and_props">Variables and props</h2>

<p>接下来，我们将使用一些 JavaScript 的技巧来让我们在 React 中编辑组件以及处理数据更加顺手。我们将讨论如何在 JSX 中 使用 variables， 并且介绍 props， props是我们用来往组件里传入数据的一种方法， 传入之后我们可以用 variable 访问传入的变量。</p>

<h3 id="Variables_in_JSX">Variables in JSX</h3>

<p>回到 <code>App.js</code>, 让我们看一下第9行:</p>

<pre class="brush: js notranslate">&lt;img src={logo} className="App-logo" alt="logo" /&gt;</pre>

<p>可以看到，  <code>&lt;img /&gt;</code> 标签的 <code>src</code> 属性只值是在大括号中的 -- <code>{logo}</code>. 这是JSX 识别变量的方式。 React 将会识别 <code>{logo}</code>， 知道您在指在我们 app 第二行引入的 logo， 然后 React 会读取这个文件它并渲染。</p>

<p>让我们试着设置一个我们自己的变量，在 <code>App</code> return 之前， 添加 <code>const subject = 'React';</code>。 您的代码现在应该如下所示：</p>

<pre class="brush: js notranslate">function App() {
  const subject = "React";
  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;img src={logo} className="App-logo" alt="logo" /&gt;
        &lt;p&gt;
          Hello, World!
        &lt;/p&gt;
      &lt;/header&gt;
    &lt;/div&gt;
  );
}</pre>

<p>把第8行的 "world" 替换成我们自己的变量  <code>subject</code> ，如下所示：</p>

<pre class="brush: js notranslate">function App() {
  const subject = "React";
  return (
    &lt;div className="App"&gt;
      &lt;header className="App-header"&gt;
        &lt;img src={logo} className="App-logo" alt="logo" /&gt;
        &lt;p&gt;
          Hello, {subject}!
        &lt;/p&gt;
      &lt;/header&gt;
    &lt;/div&gt;
  );
}</pre>

<p>当我们保存时， 浏览器将会显示 "Hello, React!"， 而不是 "Hello, world!"</p>

<p>变量十分方便，但是我们没有利用到 React 的特性， 接下来我们将介绍 Props。</p>

<h3 id="Component_props">Component props</h3>

<p><strong>prop</strong> 是任何传入 React 组件的数据。Props 写在组件中，并且像 HTML 属性一样写成 <code>prop="value"</code>。 让我们打开 <code>index.js</code> 并且为我们的 <code>&lt;App/&gt;</code> 添加第一个 prop。</p>

<p>为 <code>&lt;App/&gt;</code> 组件添加一个叫 <code>subject</code> 并有着 <code>Clarice</code> 值的 prop。 当完成之后，您的代码应如下所示： </p>

<pre class="brush: js notranslate">ReactDOM.render(&lt;App subject="Clarice" /&gt;, document.getElementById('root'));</pre>

<p> 回到 <code>App.js</code>， 代码应该如下所示 （return 中的内容省略了）

<pre class="brush: js notranslate">function App() {
  const subject = "React";
  return (
    // return statement
  );
}</pre>

<p>改变 <code>App</code> 的函数签名，让它接收 <code>props</code> 作为一个参数。 就像其它参数一样， 您可以把 <code>props</code> 放在 <code>console.log()</code> 中，让其在浏览器打印出来。 把它放在您的 <code>subject</code> 之后，以及 <code>return</code> 之前， 您的代码应如下所示：</p>

<pre class="brush: js notranslate">function App(props) {
  const subject = "React";
  console.log(props);
  return (
    // return statement
  );
}</pre>

<p>保存您的文件并检查您浏览器中的 JavaScript Console， 您将会发现如下所示的语句：</p>

<pre class="brush: js notranslate">Object { subject: "Clarice" }</pre>

<p> 对象的 <code>subject</code> 属性与我们放入 <code>App</code> 函数签名的 prop 相对应，并且 <code>Clarice</code> 字符串与它的值相对应， 在 React 中的组件 props 总是用这种方式传入object 中。</p>

<p> 现在 <code>subject</code> 是我们的 props 之一了， 让我们在 <code>App.js</code> 中使用它。 用 <code>props.subject</code> 替代原本的 <code>React</code> 字符串， 如果你想的话，也可以删除 <code>console.log()</code>， 您的代码将如下所示：

<pre class="brush: js notranslate">function App(props) {
  const subject = props.subject;
  return (
    // return statement
  );
}</pre>

<p>当您保存之后， app 应该会输出 "Hello, Clarice!"。 如果您回到 <code>index.js</code>， 并且修改 <code>subject</code> 的值并保存， 您输出的字也会随之改变。 </p>

<h2 id="Summary">总结</h2>


<p>以上就是我们对 React 的初步认识， 包括如何在本地下载它， 创建一个初始 app， 以及一些基本的操作。 在下篇文章，我们将会开始创建我们的第一个 app -- 一个任务清单。在我们开始下篇文章之前，让我们先复习下我们现在所学的。</p>

<p>在 React 中:</p>

<ul>
 <li>组件可以 import 它们需要的模块，并且在文件底部将自身 export，以让其它组件使用。</li>
 <li>组件是用 <code>PascalCase</code> 也就是帕斯卡命名法命名的。</li>
 <li>通过把变量放在大括号中，您可以读取 JSX 的变量， 如<code>{so}</code> </li>
 <li>一些 JSX 属性与 HTML 属性不相同，这样就不会与JavaScript的保留字相冲突，比如说，在 HTML 中的  <code>class</code> 会在 JSX 中转译为 <code>className</code>。 注意这些属性都是驼峰式命名的。</li>
 <li>Props 就像属性一样写在组件里，并且传入组件。</li>
</ul>

<p>{{PreviousMenuNext("Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Main_features","Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_todo_list_beginning", "Learn/Tools_and_testing/Client-side_JavaScript_frameworks")}}</p>

<h2 id="In_this_module">In this module</h2>

<ul>
 <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Introduction">Introduction to client-side frameworks</a></li>
 <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Main_features">Framework main features</a></li>
 <li>React
  <ul>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_getting_started">Getting started with React</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_todo_list_beginning">Beginning our React todo list</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_components">Componentizing our React app</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_interactivity_events_state">React interactivity: Events and state</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_interactivity_filtering_conditional_rendering">React interactivity: Editing, filtering, conditional rendering</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_accessibility">Accessibility in React</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/React_resources">React resources</a></li>
  </ul>
 </li>
 <li>Ember
  <ul>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_getting_started">Getting started with Ember</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_structure_componentization">Ember app structure and componentization</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_interactivity_events_state">Ember interactivity: Events, classes and state</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_conditional_footer">Ember Interactivity: Footer functionality, conditional rendering</a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_routing"><font><font>在Ember中路由</font></font></a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Ember_resources">Ember资源和故障排除</a></li>
  </ul>
 </li>
 <li><font><font>Vue</font></font>
  <ul>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_getting_started"><font><font>Vue入门</font></font></a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_first_component"><font><font>创建我们的第一个Vue组件</font></font></a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_rendering_lists"><font><font>渲染Vue组件列表</font></font></a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_methods_events_models"><font><font>添加新的待办事项表单：Vue事件，方法和模型</font></font></a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_styling"><font><font>使用CSS样式化Vue组件</font></font></a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_computed_properties"><font><font>使用Vue计算的属性</font></font></a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_conditional_rendering"><font><font>Vue条件渲染：编辑现有待办事项</font></font></a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_refs_focus_management"><font><font>使用Vue裁判进行焦点管理</font></font></a></li>
   <li><a href="/en-US/docs/Learn/Tools_and_testing/Client-side_JavaScript_frameworks/Vue_resources"><font><font>Vue资源</font></font></a></li>
  </ul>
 </li>
</ul>
