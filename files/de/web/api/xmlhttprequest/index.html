---
title: XMLHttpRequest
slug: Web/API/XMLHttpRequest
translation_of: Web/API/XMLHttpRequest
---
<p>{{APIRef("XMLHttpRequest")}}</p>

<p><code>XMLHttpRequest</code> ist ein <a href="/JavaScript" title="JavaScript">JavaScript</a> Objekt, das von Microsoft entwickelt und von Mozilla, Apple, und Google übernommen wurde. Es wird derzeit <a href="http://www.w3.org/TR/XMLHttpRequest/">im W3C standardisiert</a>. Es bietet einen einfachen Weg, Daten von einem URL zu erhalten. Trotz seines Namens kann man mit <code>XMLHttpRequest</code> jede Art von Daten laden, nicht nur XML, und es unterstützt auch andere Protokolle als <a href="/en-US/docs/HTTP" title="HTTP">HTTP</a> (inklusive <code>file</code> und <code>ftp</code>).</p>

<p>Eine Instanz von <code>XMLHttpRequest</code> erzeugt man ganz einfach so:</p>

<pre>var myRequest = new XMLHttpRequest();
</pre>

<p>Für Näheres zur Verwendung von <code>XMLHttpRequest</code>, siehe <a href="/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest" title="Using XMLHttpRequest">Using XMLHttpRequest</a>.</p>

<h2 id="Übersicht_Methoden">Übersicht: Methoden</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <td><code><a href="#XMLHttpRequest()" title="DOM/XMLHttpRequest#XMLHttpRequest()">XMLHttpRequest</a>(JSObject objParameters);</code></td>
  </tr>
  <tr>
   <td><code>void <a href="#abort()" title="DOM/XMLHttpRequest#abort()">abort</a>();</code></td>
  </tr>
  <tr>
   <td><code>DOMString <a href="#getAllResponseHeaders()" title="DOM/XMLHttpRequest#getAllResponseHeaders()">getAllResponseHeaders</a>();</code></td>
  </tr>
  <tr>
   <td><code>DOMString? <a href="#getResponseHeader()" title="DOM/XMLHttpRequest#getResponseHeader()">getResponseHeader</a>(DOMString header);</code></td>
  </tr>
  <tr>
   <td><code>void <a href="#open()" title="DOM/XMLHttpRequest#open()">open</a>(DOMString method, DOMString url, optional boolean async, optional DOMString? user, optional DOMString? password);</code></td>
  </tr>
  <tr>
   <td><code>void <a href="#overrideMimeType()" title="DOM/XMLHttpRequest#overrideMimeType()">overrideMimeType</a>(DOMString mime);</code></td>
  </tr>
  <tr>
   <td><code>void <a href="#send()" title="DOM/XMLHttpRequest#send()">send</a>();</code><br>
    <code>void <a href="#send()" title="DOM/XMLHttpRequest#send()">send</a>(ArrayBuffer data);</code><br>
    <code>void <a href="#send()" title="DOM/XMLHttpRequest#send()">send</a>(Blob data);</code><br>
    <code>void <a href="#send()" title="DOM/XMLHttpRequest#send()">send</a>(Document data);</code><br>
    <code>void <a href="#send()" title="DOM/XMLHttpRequest#send()">send</a>(DOMString? data);</code><br>
    <code>void <a href="#send()" title="DOM/XMLHttpRequest#send()">send</a>(FormData data);</code></td>
  </tr>
  <tr>
   <td><code>void <a href="#setRequestHeader()" title="DOM/XMLHttpRequest#setRequestHeader()">setRequestHeader</a>(DOMString header, DOMString value);</code></td>
  </tr>
  <tr>
   <th>Nicht-Standard Methoden</th>
  </tr>
  <tr>
   <td><code>[noscript] void <a href="#init()" title="DOM/XMLHttpRequest#init()">init</a>(in nsIPrincipal principal, in nsIScriptContext scriptContext, in nsPIDOMWindow ownerWindow);</code></td>
  </tr>
  <tr>
   <td><code>[noscript] void <a href="#openRequest()" title="DOM/XMLHttpRequest#openRequest()">openRequest</a>(in AUTF8String method, in AUTF8String url, in boolean async, in AString user, in AString password); </code></td>
  </tr>
  <tr>
   <td><code>void <a href="#sendAsBinary()" title="DOM/XMLHttpRequest#sendAsBinary()">sendAsBinary</a>(in DOMString body);</code></td>
  </tr>
 </tbody>
</table>

<h2 id="Eigenschaften">Eigenschaften</h2>

<table class="standard-table">
 <tbody>
  <tr>
   <th>Attribut</th>
   <th>Typ</th>
   <th>Beschreibung</th>
  </tr>
  <tr id="onreadystatechange">
   <td>
    <p><code>onreadystatechange</code></p>
   </td>
   <td><code>Function?</code></td>
   <td>
    <p>Ein JavaScript function Objekt, das bei jedem Wechsel des <code>readyState</code> Attributs aufgerufen wird. Das Callback wird aus dem Thread der Benutzerschnittstelle aufgerufen.</p>

    <div class="warning"><strong>Warnung:</strong> Dies <em>sollte</em> nicht mit synchronen Anfragen und <em>darf</em> nicht aus nativem Code heraus verwendet werden.</div>
   </td>
  </tr>
  <tr id="readyState">
   <td><code>readyState</code></td>
   <td><code>unsigned short</code></td>
   <td>
    <p>Der Status der Anfrage:</p>

    <table class="standard-table">
     <tbody>
      <tr>
       <td class="header">Wert</td>
       <td class="header">Status</td>
       <td class="header">Beschreibung</td>
      </tr>
      <tr>
       <td><code>0</code></td>
       <td><code>UNSENT</code></td>
       <td><code>open()</code>wurde noch nicht aufgerufen.</td>
      </tr>
      <tr>
       <td><code>1</code></td>
       <td><code>OPENED</code></td>
       <td><code>send()</code>wurde noch nicht aufgerufen.</td>
      </tr>
      <tr>
       <td><code>2</code></td>
       <td><code>HEADERS_RECEIVED</code></td>
       <td><code>send()</code> wurde aufgerufen, und Headers sowie Status sind verfügbar.</td>
      </tr>
      <tr>
       <td><code>3</code></td>
       <td><code>LOADING</code></td>
       <td>Download ist im Gange; <code>responseText</code> enthält bereits unvollständige Daten.</td>
      </tr>
      <tr>
       <td><code>4</code></td>
       <td><code>DONE</code></td>
       <td>Der Vorgang ist abgeschlossen.</td>
      </tr>
     </tbody>
    </table>
   </td>
  </tr>
  <tr id="response">
   <td><code>response</code></td>
   <td>variiert</td>
   <td>
    <p>Der Entitätskörper der Antwort (response entity body) gemäss <code><a href="#responseType">responseType</a></code>, als ein <a href="/en-US/docs/JavaScript_typed_arrays/ArrayBuffer" title="JavaScript typed arrays/ArrayBuffer"><code>ArrayBuffer</code></a>, <a href="/en-US/docs/DOM/Blob" title="DOM/Blob"><code>Blob</code></a>, {{domxref("Document")}}, JavaScript Objekt (für "json"), oder string. Dies ist <code>null</code> falls die Anfrage nicht abgeschlossen ist oder erfolglos war.</p>
   </td>
  </tr>
  <tr id="responseText">
   <td><code>responseText</code> {{ReadOnlyInline}}</td>
   <td><code>DOMString</code></td>
   <td>Die Antwort auf die Anfrage als Text, oder <code>null</code> falls die Anfrage nicht abgeschlossen ist oder erfolglos war.</td>
  </tr>
  <tr id="responseType">
   <td><code>responseType</code></td>
   <td><code>XMLHttpRequestResponseType</code></td>
   <td>
    <p>Kann gesetzt werden, um den Datentyp der Antwort zu ändern.</p>

    <table class="standard-table" style="width: auto;">
     <tbody>
      <tr>
       <td class="header">Wert</td>
       <td class="header">Datentyp der <code>response</code> Eigenschaft</td>
      </tr>
      <tr>
       <td><code>""</code> (leerer String)</td>
       <td>String (Das ist der Default)</td>
      </tr>
      <tr>
       <td><code>"arraybuffer"</code></td>
       <td><a href="/en-US/docs/JavaScript_typed_arrays/ArrayBuffer" title="JavaScript typed arrays/ArrayBuffer"><code>ArrayBuffer</code></a></td>
      </tr>
      <tr>
       <td><code>"blob"</code></td>
       <td>{{domxref("Blob")}}</td>
      </tr>
      <tr>
       <td><code>"document"</code></td>
       <td>{{domxref("Document")}}</td>
      </tr>
      <tr>
       <td><code>"json"</code></td>
       <td>JavaScript Objekt, geparsed aus einem JSON String, der vom Server zurückgegeben wird.</td>
      </tr>
      <tr>
       <td><code>"text"</code></td>
       <td>String</td>
      </tr>
      <tr>
       <td><code>"moz-blob"</code></td>
       <td>Wird von Firefox verwendet, um den Bezug partieller {{domxref("Blob")}} Daten von <code>progress</code> Events zu erlauben. Dadurch kann ein <code>progress</code> Event Handler bereits mit der Verarbeitung von Daten beginnen, während ihr Empfang noch läuft.</td>
      </tr>
      <tr>
       <td><code>"moz-chunked-text"</code></td>
       <td>
        <p>Ähnlich wie <code>"text"</code>, aber streamt die Daten. Das bedeutet, dass der Wert in <code>response</code> nur während des <code>"progress"</code> Event verfügbar ist und jeweils nur die Daten enthält, die seit dem letzten <code>"progress"</code> Event eingetroffen sind.</p>

        <p>Wenn auf <code>response</code> während eines <code>"progress"</code> Events zugegriffen wird, enthält es einen String mit den Daten. Andernfalls gibt es <code>null</code> zurück.</p>

        <p>Dieser Modus funktioniert derzeit nur in Firefox.</p>
       </td>
      </tr>
      <tr>
       <td><code>"moz-chunked-arraybuffer"</code></td>
       <td>
        <p>Ähnlich wie <code>"arraybuffer"</code>, aber streamt die Daten. Das bedeutet, dass der Wert in <code>response</code> nur während des <code>"progress"</code> Event verfügbar ist und jeweils nur die Daten enthält, die seit dem letzten <code>"progress"</code> Event eingetroffen sind.</p>

        <p>Wenn auf <code>response</code> während eines <code>"progress"</code> Events zugegriffen wird, enthält es einen <code>ArrayBuffer</code> mit den Daten. Andernfalls gibt es <code>null</code> zurück.</p>

        <p>Dieser Modus funktioniert derzeit nur in Firefox.</p>
       </td>
      </tr>
     </tbody>
    </table>

    <div class="note"><strong>Anmerkung:</strong> Ab Gecko 11.0  sowie WebKit build 528 kann man in diesen Browsern das <code>responseType</code> Attribut nicht mehr für synchrone Anfragen benutzen. Der Versuch löst einen <code>NS_ERROR_DOM_INVALID_ACCESS_ERR</code> Fehler aus. Diese Änderung wurde dem W3C zur Standardisierung vorgeschlagen.</div>
   </td>
  </tr>
  <tr id="responseXML">
   <td><code>responseXML</code> {{ReadOnlyInline}}</td>
   <td><code>Document?</code></td>
   <td>
    <p>Die Antwort auf die Anfrage als DOM <code><a href="/en-US/docs/DOM/document" title="DOM/Document">Document</a></code> Objekt, oder <code>null</code> falls die Anfrage erfolglos war, noch nicht gesendet wurde, oder nicht als XML oder HTML geparst werden kann. Die Antwort wird geparst, als wäre sie ein <code>text/xml</code> Stream. Wenn der <code>responseType</code> auf <code>"document"</code> gesetzt wurde und die Anfrage asynchron gemacht wurde, wird die Antwort geparst, als wäre sie ein <code>text/html</code> Stream.</p>

    <div class="note"><strong>Anmerkung:</strong> Falls der Server nicht den <code>text/xml</code> Inhaltstyp-Header auf die Antwort anwendet, kann man<code> overrideMimeType()</code> verwenden, um <code>XMLHttpRequest</code> zu zwingen, sie dennoch als XML zu parsen.</div>
   </td>
  </tr>
  <tr id="status">
   <td><code>status</code> {{ReadOnlyInline}}</td>
   <td><code>unsigned short</code></td>
   <td>Der Status der Antwort auf die Anfrage. Das ist der HTTP Ergebnis-Code (<code>status</code> ist z.B. 200 für eine erfolgreiche Anfrage).</td>
  </tr>
  <tr id="statusText">
   <td><code>statusText</code> {{ReadOnlyInline}}</td>
   <td><code>DOMString</code></td>
   <td>Der Antwort-String, der vom HTTP Server zurückgesendet wurde. Im Gegensatz zu <code>status</code> beinhaltet dies den ganzen Text der Antwortnachricht (z.B. "<code>200 OK</code>").</td>
  </tr>
  <tr id="timeout">
   <td><code>timeout</code></td>
   <td><code>unsigned long</code></td>
   <td>
    <p>Die Anzahl Millisekunden, die eine Anfrage dauern darf, bevor sie automatisch abgebrochen wird. Ein Wert von 0 (das ist die Voreinstellung) bedeutet, dass es kein timeout gibt.</p>

    <div class="note"><strong>Anmerkung:</strong> Für synchrone Anfragen mit einem besitzenden Fenster darf man kein timeout verwenden.</div>
   </td>
  </tr>
  <tr id="upload">
   <td><code>upload</code></td>
   <td><code>XMLHttpRequestUpload</code></td>
   <td>Das Hochladen kann mitverfolgt werden, indem man einen Event Listener zu <code>upload</code> hinzufügt.</td>
  </tr>
  <tr id="withCredentials">
   <td><code>withCredentials</code></td>
   <td><code>boolean</code></td>
   <td>
    <p>Zeigt an, ob Site-übergreifende <code>Access-Control</code> Anfragen mit Credentials wie Cookies oder Autorisierungs-Headers durchgeführt werden sollen oder nicht. Die Voreinstellung ist <code>false</code>.</p>

    <div class="note"><strong>Anmerkung:</strong> Anfragen an die ursprüngliche Site sind davon niemals betroffen.</div>

    <div class="note"><strong>Anmerkung:</strong> Ab Gecko 11.0 kann man das <code>withCredentials</code> Attribut nicht mehr für synchrone Anfragen verwenden. Der Versuch löst einen <code>NS_ERROR_DOM_INVALID_ACCESS_ERR</code> Fehler aus.</div>
   </td>
  </tr>
 </tbody>
</table>

<h3 id="Nicht-Standard_Eigenschaften">Nicht-Standard Eigenschaften</h3>

<table class="standard-table">
 <tbody>
  <tr>
   <th>Attribut</th>
   <th>Typ</th>
   <th>Description</th>
  </tr>
  <tr id="channel">
   <td><code>channel</code> {{ReadOnlyInline}}</td>
   <td>{{Interface("nsIChannel")}}</td>
   <td>Der Kanal, der vom Objekt zur Durchführung der Anfrage verwendet wurde. Das ist <code>null</code> falls der Kanal noch nicht erzeugt worden ist. Im Falle von mehrteiligen Anfragen ist das der anfängliche Kanal, nicht derjenige der anderen Teile der mehrteiligen Anfrage.<br>
    <strong>Zugriff nur mit erhöhten Rechten.</strong></td>
  </tr>
  <tr id="mozAnon">
   <td><code>mozAnon</code> {{ReadOnlyInline}}</td>
   <td><code>boolean</code></td>
   <td>
    <p>Falls <code>true</code> wird die Anfrage ohne Cookie und Authentisierungs-Headers gesendet.</p>
   </td>
  </tr>
  <tr id="mozSystem">
   <td><code>mozSystem</code> {{ReadOnlyInline}}</td>
   <td><code>boolean</code></td>
   <td>
    <p>Falls <code>true</code> wird die Regel, die nur Anfragen zum gleichen Ursprung erlaubt, für diese Anfrage nicht durchgesetzt.</p>
   </td>
  </tr>
  <tr id="mozBackgroundRequest">
   <td><code>mozBackgroundRequest</code></td>
   <td><code>boolean</code></td>
   <td>
    <p>Zeigt an, ob das Objekt eine Service-Anfrage im Hintergrund darstellt. Falls <code>true</code> wird keine Lastgruppe mit der Anfrage verknüpft, und die Anzeige von Sicherheits-Dialogen wird verhindert. <strong>Zugriff nur mit erhöhten Rechten.</strong></p>

    <p>In Fällen, wo normalerweise ein Sicherheits-Dialog angezeigt würde (wie Autorisierungs- oder Zertifikatsfehler-Benachrichtigungen), schlägt die Anfrage stattdessen einfach fehl.</p>

    <div class="note"><strong>Anmerkung: </strong>Diese Eigenschaft muss vor dem Aufrufen von <code>open()</code> gesetzt werden..</div>
   </td>
  </tr>
  <tr id="mozResponseArrayBuffer">
   <td><code>mozResponseArrayBuffer</code>  {{obsolete_inline("6")}} {{ReadOnlyInline}}</td>
   <td><a href="/en-US/docs/JavaScript_typed_arrays/ArrayBuffer" title="JavaScript typed arrays/ArrayBuffer"><code>ArrayBuffer</code></a></td>
   <td>Die Antwort auf die Anfrage, als typisiertes JavaScript Array. Dies ist <code>NULL</code> falls die Anfrage erfolglos war oder noch nicht gesendet wurde.</td>
  </tr>
  <tr id="multipart">
   <td><code>multipart</code> {{obsolete_inline("22")}}</td>
   <td><code>boolean</code></td>
   <td>
    <p><strong>Dieses nur in Gecko verfügbare Feature wurde in Firefox/Gecko 22 entfernt.</strong> Bitte verwende stattdessen <a href="/en-US/docs/Server-sent_events" title="Server-sent_events">Server-Sent Events</a>, <a href="/en-US/docs/WebSockets" title="WebSockets">Web Sockets</a> oder <code>responseText</code> aus <code>progress </code>Events.</p>

    <p>Zeigt an, ob als Antwort ein Stream von möglicherweise mehreren XML Dokumenten erwartet wird. Wird dies auf <code>true</code> gesetzt, muss der Inhaltstyp des ersten Teils der Antwort <code>multipart/x-mixed-replace</code> sein, sonst tritt ein Fehler auf. Alle Anfragen müssen asynchron sein.</p>

    <p>Dies ermöglicht die Unterstützung von Server Push; für jedes XML Dokument, das in die Antwort auf diese Anfrage geschrieben wird, wird ein neues XML DOM Dokument erzeugt, und zwischen den Dokumenten wird der <code>onload</code> Handler aufgerufen.</p>

    <div class="note"><strong>Anmerkung:</strong> Wenn dies gesetzt ist, werden <code>onload</code> und andere Event Handler nicht zurückgesetzt, nachdem das erste XML Dokument geladen ist, und der <code>onload</code> Handler wird nach Erhalt jedes Teils der Antwort aufgerufen.</div>
   </td>
  </tr>
 </tbody>
</table>

<h2 id="Konstruktor">Konstruktor</h2>

<h3 id="XMLHttpRequest()" name="XMLHttpRequest()">XMLHttpRequest()</h3>

<p>Der Konstruktor initiiert ein <code>XMLHttpRequest</code> Objekt. Er muss vor allen anderen Methoden aufgerufen werden.</p>

<p>Gecko/Firefox 16 fügt einen nicht-standard Parameter zum Konstruktor hinzu, der den anonymen Modus einschalten kann (siehe <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=692677" title="692677 – Relax same-origin XHR restrictions for privileged applications">Bug 692677</a>). Das <code>mozAnon</code> flag auf <code>true</code> zu setzen, hat einen ähnlichen Effekt wie der <a href="http://www.w3.org/TR/2012/WD-XMLHttpRequest-20120117/#dom-anonxmlhttprequest" title="see AnonXMLHttpRequest in the XMLHttpRequest specification"><code>AnonXMLHttpRequest()</code></a> Konstruktor, der in der XMLHttpRequest Spezifikation beschrieben ist, aber noch in keinem Browser implementiert wurde (Stand September 2012).</p>

<pre>XMLHttpRequest (
  JSObject objParameters
);</pre>

<h5 id="Parameter_(nicht-standard)">Parameter (nicht-standard)</h5>

<dl>
 <dt><code>objParameters</code></dt>
 <dd>Es gibt zwei Flags, die gesetzt werden können:
 <dl>
  <dt><code>mozAnon</code></dt>
  <dd>Boolean: Wenn dieses Flag auf <code>true</code> gesetzt ist, wird der Browser weder den Ursprung der Anfrage noch <a href="http://www.w3.org/TR/2012/WD-XMLHttpRequest-20120117/#user-credentials" title="Defintion of “User credentials” in the XMLHttpRequest specification.">Anmeldedaten</a> übermitteln, wenn er Daten anfordert. Das heisst vor allem auch, dass keine Cookies gesendet werden, sofern sie nicht ausdrücklich mit setRequestHeader hinzugefügt wurden.</dd>
  <dt><code>mozSystem</code></dt>
  <dd>Boolean: Dieses Flag auf <code>true</code> zu setzen, ermöglicht das Herstellen von Cross-Site Verbindungen, ohne dass der Server dem mittels CORS zustimmen muss. <em>Erfodert das Setzen von <code>mozAnon: true</code>. D.h. das kann nicht mit dem Senden von Cookies oder anderen Anmeldeinformationen kombiniert werden. Dies <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=692677#c68" title="Bug 692677 comment 68">funktioniert nur in privilegierten (reviewed) Apps</a>; es klappt nicht auf beliebigen Webseiten, die in Firefox geladen werden.</em></dd>
 </dl>
 </dd>
</dl>

<h2 id="Methoden">Methoden</h2>

<h3 id="abort()" name="abort()">abort()</h3>

<p>Bricht die Anfrage ab, falls sie bereits gesendet wurde.</p>

<h3 id="getAllResponseHeaders()" name="getAllResponseHeaders()">getAllResponseHeaders()</h3>

<pre>DOMString getAllResponseHeaders();</pre>

<p>Liefert alle Antwort-Header als String, oder <code>null</code> falls keine Antwort empfangen wurde.<strong> </strong></p>

<p><strong>Anmerkung:</strong> Für mehrteilige Anfragen gibt dies die Header des <em>aktuellen </em>Teils der Anfrage zurück, nicht die des ursprünglichen Kanals.</p>

<h3 id="getResponseHeader()" name="getResponseHeader()">getResponseHeader()</h3>

<pre>DOMString? getResponseHeader(DOMString <var>header</var>);</pre>

<p>Liefert den String mit dem Text des angegebenen Headers, oder <code>null</code> falls die Antwort noch nicht empfangen wurde oder der Header in der Antwort nicht existiert.</p>

<h3 id="open()" name="open()">open()</h3>

<p>Initialisiert eine Anfrage. Diese Methode ist nur zur Verwendung in JavaScript Code; um eine Anfrage aus nativem Code zu initialisieren, ist stattdessen<code> </code><a href="/en-US/docs/nsIXMLHttpRequest#openRequest()" title="XMLHttpRequest#openRequest()"><code>openRequest()</code></a> zu benutzen.</p>

<div class="note"><strong>Anmerkung:</strong> Der Aufruf dieser Methode für eine bereits aktive Anfrage (eine, für die <code>open()</code>oder <code>openRequest() </code>schon ausgeführt wurde) ist gleichwertig mit  dem Aufruf von <code>abort()</code>.</div>

<pre>void open(
   DOMString <var>method</var>,
   DOMString <var>url</var>,
   optional boolean <var>async</var>,
   optional DOMString <var>user</var>,
   optional DOMString <var>password</var>
);
</pre>

<h6 id="Parameter">Parameter</h6>

<dl>
 <dt><code>method</code></dt>
 <dd>Die zu benutzende HTTP Methode,  wie "GET", "POST", "PUT", "DELETE", etc. Wird für nicht-HTTP(S) URLs ignoriert.</dd>
 <dt><code>url</code></dt>
 <dd>Der URL, an den die Anfrage geschickt werden soll.</dd>
 <dt><code>async</code></dt>
 <dd>Ein optionaler boole'scher Parameter mit Defaultwert <code>true</code>, der angibt, ob die Operation asynchron ausgeführt werden soll. Wenn dieser Wert <code>false</code> ist, kehrt die <code>send()</code>Methode nicht zurück, bis die Antwort vollständig empfangen worden ist. Ist er <code>true</code>, kehrt sie sofort zurück, und die Benachrichtigung über die vollendete Transaktion erfolgt mittels Events. Dies <em>muss</em> <code>true</code> sein falls das <code>multipart</code> Attribut <code>true</code> ist, sonst wird ein Fehler ausgelöst.</dd>
 <dt><code>user</code></dt>
 <dd>Der optionale Benutzername zum Zweck der Authentisierung; ohne Angabe ist dies ein leerer String.</dd>
 <dt><code>password</code></dt>
 <dd>Das optionale Passwort zum Zweck der Authentisierung; ohne Angabe ist dies ein leerer String.</dd>
</dl>

<h3 id="overrideMimeType()" name="overrideMimeType()">overrideMimeType()</h3>

<p>Übergeht den vom Server zurückgegebenen MIME Typ. Dies kann beispielsweise benutzt werden, um zu erzwingen, dass ein Stream als text/xml behandelt und geparst wird, selbst wenn ihn der Server nicht als das meldet. Diese Methode muss vor <code>send()</code> aufgerufen werden.</p>

<pre>void overrideMimeType(DOMString <var>mimetype</var>);</pre>

<h3 id="send()" name="send()">send()</h3>

<p>Sendet die Anfrage. Falls die Anfage asynchron ist (was der Default ist), kehrt diese Methode zurück, sobald die Anfrage gesendet ist. Ist die Anfrage synchron, kehrt diese Methode nicht zurück, bis die Antwort angekommen (oder ein Timeout aufgetreten) ist.</p>

<div class="note"><strong>Anmerkung:</strong> Jegliche zu setzende Event Handler / Listener müssen vor dem Aufruf von <code>send()</code> gesetzt werden.</div>

<pre>void send();
void send(ArrayBuffer <var>data</var>);
void send(Blob <var>data</var>);
void send(Document <var>data</var>);
void send(DOMString? <var>data</var>);
void send(FormData <var>data</var>);</pre>

<h6 id="Anmerkungen">Anmerkungen</h6>

<p>Falls <em>data</em> ein <code>Document</code> ist, so wird dieses vor dem Senden serialisiert. Beim Senden eines <code>Document</code> senden Firefox Versionen vor Version 3 die Anfrage immer encodiert als UTF-8; <a href="/en-US/docs/Firefox_3" rel="internal" title="Firefox_3">Firefox 3</a> sendet das <code>Document</code> richtigerweise mit dem angegebenen <code>body.xmlEncoding</code>, oder UTF-8 falls keines angegeben wurde.</p>

<p>Falls es ein <code>nsIInputStream</code> ist, muss er kompatibel sein mit der <code>setUploadStream()</code>Methode des <code>nsIUploadChannel</code>. In diesem Fall wird die Länge des Inhalts in einem Content-Length Header zur Anfrage hinzugefügt, dessen Wert mit der <code>available()</code>Methode des <code>nsIInputStream</code> ermittelt wird. Jegliche Header, die am Anfang des Streams enthalten sind, werden als Teil des Nachrichtenkörpers behandelt. Der MIME Typ des Streams sollte vor dem Aufruf von <code>send()</code> angegeben werden, indem der Content-Type Header mit der  <a href="/en-US/docs/nsIXMLHttpRequest#setRequestHeader()" title="XMLHttpRequest#setRequestHeader()"><code>setRequestHeader()</code></a> Methode gesetzt wird.</p>

<p>Der beste Weg, um binäre Inhalte zu senden (wie beim Hochladen einer Datei), ist die Verwendung von <a href="/en-US/docs/JavaScript/Typed_arrays/ArrayBuffer" title="JavaScript/Typed_arrays/ArrayBuffer">ArrayBuffern</a> oder <a href="/en-US/docs/DOM/Blob" title="DOM/Blob">Blobs</a> in Verbindung mit der <code>send()</code> Methode. Wenn jedoch <a href="/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify" title="JavaScript/Reference/Global_Objects/JSON/stringify">stringifizierbare</a> Rohdaten gesendet werden sollen, ist die <a href="#sendAsBinary()" title="DOM/XMLHttpRequest#sendAsBinary()"><code>sendAsBinary()</code></a> Methode zu verwenden.</p>

<h3 id="setRequestHeader()" name="setRequestHeader()">setRequestHeader()</h3>

<p>Setzt den Wert eines HTTP Anfrage-Headers. Aufrufe von <code>setRequestHeader()</code> müssen nach <a href="#open"><code>open()</code></a>, aber vor <code>send()</code> erfolgen.</p>

<pre>void setRequestHeader(
   DOMString <var>header</var>,
   DOMString <var>value</var>
);
</pre>

<h6 id="Parameter_2">Parameter</h6>

<dl>
 <dt><code>header</code></dt>
 <dd>Der Name des zu setzenden Headers.</dd>
 <dt><code>value</code></dt>
 <dd>Der Wert des zu setzenden Headers.</dd>
</dl>

<h3 id="Nicht-Standard_Methoden">Nicht-Standard Methoden</h3>

<h4 id="init()">init()</h4>

<p>Initialisiert das Objekt für die Verwendung aus C++ Code.</p>

<div class="warning"><strong>Warnung:</strong> Diese Methode darf <em>nicht</em> aus JavaScript heraus aufgerufen werden.</div>

<pre>[noscript] void init(
   in nsIPrincipal principal,
   in nsIScriptContext scriptContext,
   in nsPIDOMWindow ownerWindow
);
</pre>

<h5 id="Parameter_3">Parameter</h5>

<dl>
 <dt><code>principal</code></dt>
 <dd>Das Prinzipal, das für die Anfrage benutzt werden soll; darf nicht <code>null</code> sein.</dd>
 <dt><code>scriptContext</code></dt>
 <dd>Der Skript-Kontext, der für die Anfrage benutzt werden soll; darf nicht <code>null</code> sein.</dd>
 <dt><code>ownerWindow</code></dt>
 <dd>Das Fenster, das zu der Anfrage gehört; darf <code>null</code> sein.</dd>
</dl>

<h4 id="openRequest()">openRequest()</h4>

<p>Initialisiert eine Anfrage. Diese Methode ist zur Verwendung in nativem Code; um eine Anfrage in JavaScript Code zu initialisieren, ist stattdessen <a href="/en-US/docs/nsIXMLHttpRequest#open()" title="XMLHttpRequest#open()"><code>open()</code></a> zu verwenden. Siehe Dokumentation für <code>open()</code>.</p>

<h3 id="sendAsBinary()">sendAsBinary()</h3>

<p>Eine Variante der <code>send()</code> Methode, die binäre Daten schickt.</p>

<pre>void sendAsBinary(
   in DOMString body
);
</pre>

<p>Diese Methode, zusammen mit der <a href="/en-US/docs/DOM/FileReader#readAsBinaryString()" title="DOM/FileReader#readAsBinaryString()"><code>readAsBinaryString</code></a> Methode der <a href="/en-US/docs/DOM/FileReader" title="DOM/FileReader"><code>FileReader</code></a> API, ermöglichen <a href="https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files" title="DOM/XMLHttpRequest/Using_XMLHttpRequest#Submitting_forms_and_uploading_files">das Lesen und den <strong>Upload</strong> jeglicher Dateitypen</a> und das <a href="/en-US/docs/JavaScript/Reference/Global_Objects/JSON/stringify" title="JavaScript/Reference/Global_Objects/JSON/stringify">Stringifizieren</a> der Rohdaten.</p>

<h5 id="Parameter_4">Parameter</h5>

<dl>
 <dt><code>body</code></dt>
 <dd>Der Körper der Anfrage als DOMstring. Diese Daten werden durch Beschneiden (Entfernen des höherwertigen Bytes jedes Zeichens) in Einzel-Byte-Zeichen umgewandelt.</dd>
</dl>

<h5 id="sendAsBinary()_polyfill"><code>sendAsBinary()</code> polyfill</h5>

<p>Da <code>sendAsBinary()</code> ein experimentelles Feature ist, kommt hier <strong>ein Polyfill</strong> für Browser, die <code>sendAsBinary()</code> <em>nicht </em>unterstützen, dafür aber <a href="/en-US/docs/JavaScript/Typed_arrays" title="JavaScript/Typed_arrays">typisierte Arrays</a>.</p>

<pre class="brush: js">/*\
|*|
|*|  :: XMLHttpRequest.prototype.sendAsBinary() Polyfill ::
|*|
|*|  https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#sendAsBinary()
|*|
\*/

if (!XMLHttpRequest.prototype.sendAsBinary) {
  XMLHttpRequest.prototype.sendAsBinary = function (sData) {
    var nBytes = sData.length, ui8Data = new Uint8Array(nBytes);
    for (var nIdx = 0; nIdx &lt; nBytes; nIdx++) {
      ui8Data[nIdx] = sData.charCodeAt(nIdx) &amp; 0xff;
    }
    /* sende als ArrayBufferView...: */
    this.send(ui8Data);
    /* ...oder als ArrayBuffer (altmodisch)...: this.send(ui8Data.buffer); */
  };
}</pre>

<div class="note"><strong>Anmerkung:</strong> Dieses Polyfill kann mit zwei Datentypen als Argument für <code>send()</code> gebaut werden: einem <a href="/en-US/docs/JavaScript/Typed_arrays/ArrayBuffer" title="JavaScript/Typed_arrays/ArrayBuffer"><code>ArrayBuffer</code></a> (<code>ui8Data.buffer</code> – kommentierter Code) oder einer <a href="/en-US/docs/JavaScript/Typed_arrays/ArrayBufferView" title="JavaScript/Typed_arrays/ArrayBufferView"><code>ArrayBufferView</code></a> (<code>ui8Data</code>, das ist ein <a href="/en-US/docs/JavaScript/Typed_arrays/Uint8Array" title="JavaScript/Typed_arrays/Uint8Array">typisiertes Array von 8-bit Ganzzahlen ohne Vorzeichen</a> – unkommentierter Code). Wenn man jedoch in Google Chrome versucht, einen <code>ArrayBuffer</code> zu senden, erscheint die folgende Warnmeldung: <code>ArrayBuffer is deprecated in XMLHttpRequest.send(). Use ArrayBufferView instead.</code></div>

<h2 id="Anmerkungen_2">Anmerkungen</h2>

<ul>
 <li class="note">Standardmässig begrenzt Firefox 3 die Anzahl gleichzeitiger <code>XMLHttpRequest</code> Verbindungen pro Server auf 6 (frühere Versionen begrenzen dies auf 2 pro Server). Manche interaktiven Websites können eine <code>XMLHttpRequest</code> Verbindung offen halten, so dass das Öffnen mehrerer Sitzungen auf solchen Sites dazu führen kann, dass der Browser auf eine Art und Weise hängen bleibt, dass das Fenster nicht mehr neu gezeichnet wird und Steuerelemente nicht mehr reagieren. Dieser Wert lässt sich ändern durch Editieren der Voreinstellung <code>network.http.max-persistent-connections-per-server</code> in <code><a class="linkification-ext" href="/about:config" title="Linkification: about:config">about:config</a></code>.</li>
 <li class="note">Ab Gecko 7 werden Header, die durch {{manch("setRequestHeader")}} gesetzt wurden, mit der Anfrage mitgeschickt, wenn einer Umleitung gefolgt wird. Zuvor wurden diese Header nicht gesendet.</li>
 <li class="note"><code>XMLHttpRequest</code> ist in Gecko implementiert mittels der {{interface("nsIXMLHttpRequest")}}, {{interface("nsIXMLHttpRequestEventTarget")}}, und {{interface("nsIJSXMLHttpRequest")}} Schnittstellen.</li>
</ul>

<h4 class="note" id="Events">Events</h4>

<p><code>onreadystatechange</code> als eine Eigenschaft der <code>XMLHttpRequest</code> Instanz wird von allen Browsern unterstützt.</p>

<p>Seither wurden einige zusätzliche Event Handler in verschiedenen Browsern implementiert (<code>onload</code>, <code>onerror</code>, <code>onprogress</code>, etc.). Diese werden in Firefox unterstützt. Für Genaueres, siehe {{interface("nsIXMLHttpRequestEventTarget")}} und <a href="/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest" title="XMLHttpRequest/Using_XMLHttpRequest">Using XMLHttpRequest</a>.</p>

<p>Neuere Browser, inklusive Firefox, unterstützen das 'Horchen' nach <code>XMLHttpRequest </code>Ereignissen mittels der Standard <code><a href="/en-US/docs/DOM/element.addEventListener" title="element.addEventListener">addEventListener</a></code> APIs zusätzlich zum Setzen von <code>on*</code> Eigenschaften auf eine Handler Funktion.</p>

<h2 id="Browser_compatibility" name="Browser_compatibility">Browser Kompatibilität</h2>

<div>{{CompatibilityTable}}</div>

<div id="compat-desktop">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Feature</th>
   <th>Chrome</th>
   <th>Firefox (Gecko)</th>
   <th>Internet Explorer</th>
   <th>Opera</th>
   <th>Safari (WebKit)</th>
  </tr>
  <tr>
   <td>Grundsätzliche Unterstützung (XHR1)</td>
   <td>1</td>
   <td>1.0</td>
   <td>5 (via ActiveXObject)<br>
    7 (XMLHttpRequest)</td>
   <td>{{CompatVersionUnknown}}</td>
   <td>1.2</td>
  </tr>
  <tr>
   <td><code>send(ArrayBuffer)</code></td>
   <td>9</td>
   <td>9</td>
   <td>{{compatUnknown}}</td>
   <td>11.60</td>
   <td>{{compatUnknown}}</td>
  </tr>
  <tr>
   <td><code>send(Blob)</code></td>
   <td>7</td>
   <td>3.6</td>
   <td>{{compatUnknown}}</td>
   <td>12</td>
   <td>{{compatUnknown}}</td>
  </tr>
  <tr>
   <td><code>send(FormData)</code></td>
   <td>6</td>
   <td>4</td>
   <td>{{compatUnknown}}</td>
   <td>12</td>
   <td>{{compatUnknown}}</td>
  </tr>
  <tr>
   <td><code>sendAsBinary(DOMString)</code></td>
   <td>{{compatNo}} – benutze <a href="#sendAsBinary%28%29_polyfill" title="sendAsBinary() polyfill">polyfill</a></td>
   <td>1.9</td>
   <td>{{compatUnknown}}</td>
   <td>{{compatUnknown}}</td>
   <td>{{compatUnknown}}</td>
  </tr>
  <tr>
   <td><code>response</code></td>
   <td>10</td>
   <td>6</td>
   <td>10</td>
   <td>11.60</td>
   <td>{{compatUnknown}}</td>
  </tr>
  <tr>
   <td><code>responseType</code> = 'arraybuffer'</td>
   <td>10</td>
   <td>6</td>
   <td>10</td>
   <td>11.60</td>
   <td>{{compatUnknown}}</td>
  </tr>
  <tr>
   <td><code>responseType</code> = 'blob'</td>
   <td>19</td>
   <td>6</td>
   <td>10</td>
   <td>12</td>
   <td>{{compatUnknown}}</td>
  </tr>
  <tr>
   <td><code>responseType</code> = 'document'</td>
   <td>18</td>
   <td>11</td>
   <td>10</td>
   <td>{{CompatNo}}</td>
   <td>{{CompatNo}}</td>
  </tr>
  <tr>
   <td><code>responseType</code> = 'json'</td>
   <td>{{CompatNo}}</td>
   <td>10</td>
   <td>{{CompatNo}}</td>
   <td>12</td>
   <td>{{CompatNo}}</td>
  </tr>
  <tr>
   <td>Progress Events</td>
   <td>7</td>
   <td>3.5</td>
   <td>10</td>
   <td>12</td>
   <td>{{compatUnknown}}</td>
  </tr>
  <tr>
   <td><code>withCredentials</code></td>
   <td>3</td>
   <td>3.5</td>
   <td>10</td>
   <td>12</td>
   <td>4</td>
  </tr>
  <tr>
   <td><code>timeout</code></td>
   <td>{{CompatNo}}</td>
   <td>12.0</td>
   <td>8</td>
   <td>{{compatUnknown}}</td>
   <td>{{CompatNo}}</td>
  </tr>
  <tr>
   <td><code>responseType</code> = 'moz-blob'</td>
   <td>{{CompatNo}}</td>
   <td>12.0</td>
   <td>{{CompatNo}}</td>
   <td>{{CompatNo}}</td>
   <td>{{CompatNo}}</td>
  </tr>
 </tbody>
</table>
</div>

<div id="compat-mobile">
<table class="compat-table">
 <tbody>
  <tr>
   <th>Feature</th>
   <th>Android</th>
   <th>Chrome für Android</th>
   <th>Firefox Mobile (Gecko)</th>
   <th>IE Phone</th>
   <th>Opera Mobile</th>
   <th>Safari Mobile</th>
  </tr>
  <tr>
   <td>Grundsätzliche Unterstützung</td>
   <td>{{CompatUnknown}}</td>
   <td>0.16</td>
   <td>{{CompatVersionUnknown}}</td>
   <td>{{CompatUnknown}}</td>
   <td>{{CompatUnknown}}</td>
   <td>{{CompatUnknown}}</td>
  </tr>
 </tbody>
</table>
</div>

<h3 id="Gecko_Anmerkungen">Gecko Anmerkungen</h3>

<p>Gecko 11.0 {{geckoRelease("11.0")}} entfernte die Unterstützung für die Verwendung der <code>responseType</code> und <code>withCredentials</code> Attribute bei der Durchführung synchroner Anfragen. Der Versuch löst einen <code>NS_ERROR_DOM_INVALID_ACCESS_ERR</code> Fehler aus. Diese Änderung wurde dem W3C zur Standardisierung vorgeschlagen.</p>

<p>Gecko 12.0 {{geckoRelease("12.0")}} und spätere unterstützen die Verwendung von <code>XMLHttpRequest</code> zum Lesen von <a href="/en-US/docs/data_URIs" title="data_URIs"><code>data:</code> URLs</a>.</p>

<h2 id="Siehe_auch">Siehe auch</h2>

<ul>
 <li>MDN Artikel über XMLHttpRequest:
  <ul>
   <li><a href="/en-US/docs/AJAX/Getting_Started" title="AJAX/Getting_Started">AJAX - Getting Started</a></li>
   <li><a href="/en-US/docs/DOM/XMLHttpRequest/Using_XMLHttpRequest" title="Using XMLHttpRequest">Using XMLHttpRequest</a></li>
   <li><a href="/en-US/docs/HTML_in_XMLHttpRequest" title="HTML_in_XMLHttpRequest">HTML in XMLHttpRequest</a></li>
   <li><a href="/en-US/docs/DOM/XMLHttpRequest/FormData" title="XMLHttpRequest/FormData"><code>FormData</code></a></li>
  </ul>
 </li>
 <li>XMLHttpRequest Referencen von W3C und Browserherstellern:
  <ul>
   <li><a href="http://www.w3.org/TR/XMLHttpRequest1/">W3C: XMLHttpRequest</a> (base features)</li>
   <li><a href="http://dvcs.w3.org/hg/xhr/raw-file/tip/Overview.html">W3C: XMLHttpRequest</a> (latest editor's draft with extensions to the base functionality, formerly XMLHttpRequest Level 2)</li>
   <li><a href="http://msdn.microsoft.com/library/default.asp?url=/library/en-us/xmlsdk/html/xmobjxmlhttprequest.asp">Microsoft documentation</a></li>
   <li><a href="http://developer.apple.com/internet/webcontent/xmlhttpreq.html">Apple developers' reference</a></li>
  </ul>
 </li>
 <li><a href="http://jibbering.com/2002/4/httprequest.html">"Using the XMLHttpRequest Object" (jibbering.com)</a></li>
 <li><a href="http://www.peej.co.uk/articles/rich-user-experience.html">XMLHttpRequest - REST and the Rich User Experience</a></li>
 <li><a href="http://www.html5rocks.com/en/tutorials/file/xhr2/">HTML5 Rocks - New Tricks in XMLHttpRequest2</a></li>
</ul>
